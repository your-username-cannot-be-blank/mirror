
    <html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <style>
    th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    th, td {
      word-wrap: break-word;
      padding: 5px;
    }
    table {
      width: 100%;
      max-width: 100%;
      border: 1px solid black;
      border-collapse: collapse;
      table-layout: fixed;
      word-wrap: break-word
    }
    code {
      word-wrap: break-word;
    }
    pre {
        white-space: pre-wrap;
    }
    </style>
        <title>идеи-и-дальнейшие-планы-51</title>
      </head>
      <body>
        <table border="1" width="100%" cellpadding="5">
          <tr>
            <th style="width: 10%;">Ник</th>
            <th>Пост</th>
            <th style="width: 10%;">Дата</th>
          </tr>
    <tr><td>ValdikSS</td><td><p>Мои идеи:</p>
<p><strong>Первая</strong> — доработка GoodbyeDPI, реализация новых способов обхода DPI, таких как TCB creation, TCB teardown, data reassembly, tcp state desync, да и просто изменение флагов в TCP SYN так, чтобы можно было менять размер SYN’а. Если интересуют подробности методов, я напишу детально.<br>
Чтобы сделать поддержку новых методов обхода, сначала нужно реализовать отслеживание состояния соединений (tcp conntrack), как минимум.<br>
Сейчас в GoodbyeDPI реализована только по-пакетная обработка, а часто в одном пакете недостаточно данных для корректного определения протокола, либо данных слишком много, чтобы они вместились в один пакет, из-за чего с ними неудобно работать в пакетном режиме. Было бы гораздо удобней писать новые методы обхода в псевдо-потоковом режиме, что-то вроде простого tcp reassembly, чтобы можно было получить данные нескольких предыдущих пакетов, или объединять их в один большой.<br>
Также нужна помощь в добавлении поддержки Linux и macOS, для этого сначала нужно вынести весь платформозависимый код в отдельный модуль, абстрагироваться от WinDivert API для обработки пакетов. Код для этого можно позаимствовать из проекта reqrypt.</p>
<p><strong>Вторая идея</strong> — сделать патчи для библиотек шифрования NSS (используется браузерами Firefox и Chrome, и основанными на них) и OpenSSL (широко используется другими программами), в части работы с сетью.<br>
Многие DPI можно обойти, добавив точку в конец домена, или изменив регистр каких-либо букв в имени домена, в TLS-хендшейке (расширение TLS Server Name Indication). Я сделал патчи для NSS, которые добавляют точку и меняют регистр, но не все TLS-стеки такое поддерживают (по стандарту, точки не должно быть). Нужно доделать патчи, сделать так, чтобы, в случае неудачи, происходило автоматическое переподключение и попытка установить соединение как обычно, без патчей, так, чтобы это было прозрачно для программ, использующих библиотеки (чтобы оригинальную библиотеку можно было заменить патченной, без необходимости правки кода самих программ). После чего можно будет выпустить портативные версии программ с патченной библиотекой, например, Firefox (для всех платформ, в т.ч. Android).</p>
<p>Кроме модификации настоящего домена в TLS SNI, можно также передавать случайные популярные домены в SNI, например, <a href="http://google.com" rel="nofollow noopener">google.com</a>, и, если удаленный сервер в ответ на это отдаст какой-то нормальный сертификат на какой-либо домен, валидировать его и разрешать соединение. Это достаточно опасная и спорная функциональность, но в качестве дополнительной возможности — сойдет.</p>
<p><strong>Третья идея</strong> — сделать библиотеку “libgoodbyedpi”, в которую можно передавать данные пакетов, а она бы возвращала измененный пакет, чтобы он обходил DPI, либо сама отправляла его в измененном виде в сеть.<br>
Я вижу два подхода к реализации: либо в виде библиотеки и патчей для популярных сетевых библиотек (libcurl, например, который бы с патчами линковался с libgoodbyedpi), либо в виде библиотеки, хукающей сетевые функции, и самостоятельно прозрачно изменяющей пакеты (чтобы можно было загрузить через LD_PRELOAD или аналогичный способ для других ОС).<br>
Что-то вроде GoodbyeDPI, только для конкретных программ, а не на всю систему целиком. Преимущество в том, что можно будет без особых проблем сделать библиотеку кросс-платформенной, и делать байндинги для разных сетевых библиотек разных операционных систем.</p></td><td>2019-09-11T11:51:51.670Z</td></tr>
    </table>
      </body>
    </html>