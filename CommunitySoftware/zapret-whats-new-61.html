
    <html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <style>
    th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    th, td {
      word-wrap: break-word;
      padding: 5px;
    }
    table {
      width: 100%;
      max-width: 100%;
      border: 1px solid black;
      border-collapse: collapse;
      table-layout: fixed;
      word-wrap: break-word
    }
    code {
      word-wrap: break-word;
    }
    pre {
        white-space: pre-wrap;
    }
    </style>
        <title>zapret-whats-new-61</title>
      </head>
      <body>
        <table border="1" width="100%" cellpadding="5">
          <tr>
            <th style="width: 10%;">Ник</th>
            <th>Пост</th>
            <th style="width: 10%;">Дата</th>
          </tr>
    <tr><td>bolvan</td><td><p>Сюда буду сбрасывать информацию о последних изменениях в проекте</p><aside class="onebox githubrepo" data-onebox-src="https://github.com/bol-van/zapret">
  <header class="source">

      <a href="https://github.com/bol-van/zapret" target="_blank" rel="noopener">github.com</a>
  </header>

  <article class="onebox-body">
    <div class="github-row" data-github-private-repo="false">
  <img width="690" height="344" src="zapret-whats-new-61/b908f24ed97549441ae7fe84f8bd9d1d478c1fbc_2_690x344.png" class="thumbnail" data-dominant-color="F1F4F1">

  <h3><a href="https://github.com/bol-van/zapret" target="_blank" rel="noopener">GitHub - bol-van/zapret: DPI bypass multi platform</a></h3>

    <p><span class="github-repo-description">DPI bypass multi platform</span></p>
</div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>КОМПЛЕКТ ДЛЯ WINDOWS : <a href="https://github.com/bol-van/zapret-win-bundle" class="inline-onebox">GitHub - bol-van/zapret-win-bundle: zapret and blockcheck binary bundle for windows</a></p>
<p>Опишу кратко назначение.<br>
Проект нацелен на прозрачный обход блокировок и замедлений веб сайтов http(s) на <strong>Windows, Linux, FreeBSD, OpenBSD, частично MacOS</strong>, в том числе на роутерах на базе <strong>openwrt</strong>. Может применяться и для противодействия сигнатурному анализу произвольных tcp и udp протоколов<br>
Он состоит из следующих компонент :</p>
<ol>
<li>Скрипты для автоматизации получения списка заблокированных ip и хостов и их обработки (ipset, ip2net, mdig).</li>
<li>Программы для обхода DPI на http и https : nfqws,dvtws,winws,tpws,</li>
<li>Скрипты задействования этих программ + фаервола на разных системах - openwrt, sysv, systemd, macos (init.d)</li>
<li>blockcheck - средство проверки рабочих методов обхода DPI</li>
<li>То, что не автоматизировано. Описательная часть для продвинутых пользователей : как организовать выборочное прозрачное проксирование соединений, заворот на VPN, способы модификации существующих VPN решений для изменений их стандартного протокола с целью скрытия от DPI</li>
</ol></td><td>2019-09-16T06:25:20.967Z</td></tr><tr><td>bolvan</td><td><p>Изменения май-июнь 2019<br>
Проект был существенно доработан.</p>
<p>Сделана максимально упрощенная установка для пользователей основных дистрибутивов linux и openwrt через скрипт install_easy.sh.<br>
Вариант по умолчанию ставит сплиттер http запросов + Host =&gt; HOST<br>
Переписаны скрипты для debian и openwrt.<br>
Убрана вся каша с провайдерами, потому что все равно не буду следить за актуальностью что на каком провайдере.<br>
Теперь все более логично. Вы выбираете что использовать : tpws или nfqws, их параметры.<br>
Можно легко самому добавлять в скрипты запуск дополнительных демонов или их копий с разными параметрами.<br>
Добавление правил firewall вынесено в отдельные процедуры, которые можно использовать при модификации скрипта.<br>
Добавление правил firewall под openwrt вынесено в отдельный firewall include /etc/firewall.zapret, чтобы /etc/firewall.user использовать для своих целей и не смешивать команды.<br>
Настройки вынесены из init скриптов в отдельный файл “config”.<br>
Все выглядит проще и лаконичней imho<br>
Листы РКН разрослись до мегабайтов. Теперь они хранятся в сжатом виде, что уменьшает в разы требования свободного места на роутере.<br>
Новая программа ip2net позволяет в 2-3 раза уменьшить ipset-ы, объединяя ip в подсети.<br>
Многопоточный ресолвер mdig делает снова реальным самостоятельный ресолвинг реестра через get_reestr.sh.<br>
Добавлены бинарики для arm64, mips64, ppc.<br>
Бинарики для всех архитектур, кроме mips64, запакованы в upx. Это уменьшает их размер в 2 раза.<br>
Сделан автоматический распознаватель архитектуры и установщик бинариков - install_bin.sh<br>
install_easy.sh в случае необнаружения подходящих бинариков может сам их собрать при условии наличия gcc,make и необходимых -dev пакетов<br>
Можно запустить install_easy с параметром “make”, чтобы форсировать сборку.<br>
Сделана поддержка ipv6. Она и раньше была в tpws, nfqws, но сейчас она пронесена через все компоненты.<br>
tpws получил дополнительные функции для привязки к определенным IP и возможности по ожиданию готовности интерфейсов,<br>
возможность чтения hostlist-ов в формате gzip<br>
Логика управления соединениями в tpws переписана на использование неблокирующих сокетов, устранены многочисленные потенциальные проблемы кода, унаследованного у взятого где-то в сети примера не лучшего качества<br>
nfqws больше не требует рута для работы, ограничиваясь сбросом capabilities до CAP_NET_ADMIN.<br>
В tpws и nfqws кроме --user добавлена возможность установки uid:gid через параметр --uid. Это полезно на android, поскольку там нет /etc/passwd.<br>
Написана документация по настройке policy based routing на примере wireguard.<br>
Описан метод модификации wireguard для противостояния возможным попыткам заблокировать VPN протоколы на DPI (суверенный рунет).</p></td><td>2019-09-16T06:26:59.576Z</td></tr><tr><td>bolvan</td><td><p>Изменения сентябрь 2019</p>
<p>Выяснилось откуда в реестре появляется миллион+ IP и этот список неудержимо растет.<br>
Автоматическое распознавание телеграм прокси.<br>
Вот вы сидите в метро через wifi, тыкаетесь в новонайденный телеграм прокси.<br>
А вас снифают. И сливают инфу РКН.<br>
Переработаны скрипты получения ipset.<br>
Добавлена поддержка листов с <a href="https://antifilter.network" rel="nofollow noopener">https://antifilter.network</a> на замену get_antizapret.<br>
умные префиксированныо-вычищенные листы оставляют нас всего лишь с десятками тысяч префиксов, что запросто потянет роутер с 64 Mb RAM<br>
Переработано получение листов непосредственно из реестра (get_reestr_*.sh)<br>
бывший get_reestr.sh переименован в get_reestr_resolve.sh. Это скрипт для самостоятельного ресолва доменов из реестра через mdig.<br>
На смену get_combined.sh пришел get_reestr_combined.sh. Теперь он работает только с реестром, не используя другие листы.<br>
get_reestr_ip.sh подтягивает IP в том виде, в каком они значатся в реестре<br>
get_reestr_ip, get_reestr_combined поддерживают теперь ipv6. Оба убирают мусор , которым на данный момент считается телеграм<br>
В ip2net добавлена поддержка ipv6 и настройка параметров через командную строку. create_ipset.sh обновлен до поддержки этой функции.<br>
Параметры ip2net вынесены в config</p></td><td>2019-09-16T06:27:27.889Z</td></tr><tr><td>bolvan</td><td><p>Добавлена поддержка режима socks4/5<br>
Он не требует повышенных привилегий, рута<br>
может использоваться на нерутированных android устройствах с программами, поддерживающими socks или через хитрые методы прозрачного заворота через tun</p></td><td>2019-09-22T15:28:21.001Z</td></tr><tr><td>ValdikSS</td><td><aside class="quote no-group" data-username="bolvan" data-post="4" data-topic="61">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/letter_avatar_proxy/v4/letter/b/8e8cbc/48.png" class="avatar"> bolvan:</div>
<blockquote>
<p>может использоваться на нерутированных android устройствах с программами, поддерживающими socks или через хитрые методы прозрачного заворота через tun</p>
</blockquote>
</aside>
<p>Для разработки программы, которая бы использовала zapret, можно взять исходный код программы <a href="https://github.com/Jigsaw-Code/Intra">Intra</a> или какого-нибудь проксификатора (например, shadowsocks). Почти все подобные программы используют badvpn tun2socks.</p></td><td>2019-09-22T18:53:21.326Z</td></tr><tr><td>bolvan</td><td><aside class="quote no-group" data-username="ValdikSS" data-post="5" data-topic="61">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/valdikss/48/2_2.png" class="avatar"> ValdikSS:</div>
<blockquote>
<p>Для разработки программы, которая бы использовала zapret, можно взять исходный код программы <a href="https://github.com/Jigsaw-Code/Intra">Intra </a> или какого-нибудь проксификатора (например, shadowsocks). Почти все подобные программы используют badvpn tun2socks.</p>
</blockquote>
</aside>
<p>Лично у меня совсем нет опыта в android development, и вряд ли я начну делать аппликуху сам. Но если кто желает, пожалуйста.<br>
Хотя, если так подумать, то при таком подходе зачем нужен бинарик tpws ? Ведь можно то же самое и на яве соорудить. Не зависеть от платформы.<br>
С tpws преимущество разве что в скорости немного. Но я не думаю, что это существенно для мобильников</p>
<p>Можно сделать универсальную аппликуху для рута и без рута. Если рут, то адвансед моде и тпвс в транспарент режиме, иначе через выкрутасы</p></td><td>2019-09-23T06:35:02.007Z</td></tr><tr><td>bolvan</td><td><p>В tpws добавлена опция --hostpad=<br>
Добавляет паддинг-хедеров перед Host: на указанное количество байтов<br>
Полезно против DPI, выполняющих реассемблинг TCP с ограниченным буфером.<br>
Если техника работает, то после некоторого количества bytes http запрос начнет проходить до сайта.<br>
Если при этом критический размер padding около MTU, значит скорее всего DPI не выполняет реассемблинг пакетов, и лучше будет использовать обычные опции --split-…<br>
Если все же реассемблинг выполняется, то критический размер будет около размера буфера DPI. Он может быть 4K или 8K, возможны и другие значения.</p></td><td>2019-09-28T08:50:28.201Z</td></tr><tr><td>bolvan</td><td><p>Реализована атака десинхронизации DPI для http и https. За основу взята идея от ValdikSS.</p></td><td>2019-11-01T16:29:33.237Z</td></tr><tr><td>AmiGO</td><td><p>Очень крутая и полезная вещь, у нескольких хостеров (включая Селектел) отлично работает, что позволяет пользоваться запрещёнкой без оверхеда на VPN с большим RTT.<br>
Спасибо!</p></td><td>2019-12-05T00:20:31.993Z</td></tr><tr><td>bolvan</td><td><aside class="quote no-group" data-username="AmiGO" data-post="9" data-topic="61">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/letter_avatar_proxy/v4/letter/a/85e7bf/48.png" class="avatar"> AmiGO:</div>
<blockquote>
<p>у нескольких хостеров (включая Селектел) отлично работает</p>
</blockquote>
</aside>
<p>Речь про десинхронизацию или другие опции ?<br>
Пока про десинхронизацию у меня нет отзывов, тестирование было крайне ограниченным</p></td><td>2019-12-05T09:49:32.105Z</td></tr><tr><td>AmiGO</td><td><p>Да, речь про десинхронизацию и она прекрасна своей изящностью в сочетании с минимальным оверхедом.</p></td><td>2019-12-05T18:05:14.131Z</td></tr><tr><td>bolvan</td><td><p>Добавлен выбор режима десинхронизации DPI.<br>
На текущий момент это может быть</p>
<ul>
<li>поддельный пакет с разрешенным запросом : --dpi-desync без параметра или --dpi-desync=fake</li>
<li>пакет сброса соединения : --dpi-desync=rst</li>
</ul></td><td>2019-12-27T12:51:17.723Z</td></tr><tr><td>bolvan</td><td><p>Добавлен режим disorder для dpi-desync.</p>
<p>В этом режиме пакет с http request или tls client hello разбивается на 2 части. Отсылка идет следующим образом :</p>
<ol>
<li>2-й сегмент</li>
<li>поддельный 1-й сегмент</li>
<li>1-й сегмент</li>
<li>поддельный 1-й сегмент</li>
</ol>
<p>цель атаки - максимально усложнить DPI реконструкцию сообщения, по которому принимается решение о блокировке</p></td><td>2020-01-03T14:10:49.319Z</td></tr><tr><td>bolvan</td><td><p>Исправлен баг, при котором была невозможна отправка поддельных пакетов ipv4 и ipv6 с одного процесса nfqws. Для 4 и 6 теперь используются разные raw сокеты.</p>
<p>Добавлен режим --dpi-desync-fooling=badseq. Испорченные sequence numbers в поддельных пакетах.<br>
Возможно сочетание любых режимов через запятую : --dpi-desync-fooling=badseq,badsum,md5sig</p></td><td>2020-01-18T11:30:40.230Z</td></tr><tr><td>bolvan</td><td><p>Отработана схема использования nfqws на мобильных модемах Huawei.<br>
Проверено на E8372. Вероятно работает на E3372 с минимальными модификациями.<br>
Возможно, на других устройствах.</p></td><td>2020-01-22T19:09:05.788Z</td></tr><tr><td>bolvan</td><td><p>Изменение window size в nfqws считается устаревшим и более не поддерживается в скриптах.<br>
На замену ему приходит более быстрая альтернатива --dpi-desync=split2, лишенная других недостатков wsize (типа невозможности заменить регистр Host: при --wsize=3 на пакетах от linux клиента)</p>
<p>В свете последних изменений переписана вводная часть readme.</p></td><td>2020-02-02T16:53:48.883Z</td></tr><tr><td>AmiGO</td><td><p>Не планируете интеграцию наработок <a href="https://github.com/Kkevsterrr/geneva" rel="nofollow noopener">https://github.com/Kkevsterrr/geneva</a> ?</p></td><td>2020-02-03T02:11:51.030Z</td></tr><tr><td>bolvan</td><td><p>Универсальный тампер движок портировать с питона не планирую<br>
Но по мере необходимости готов добавлять новые стратегии, работающие в exUSSR</p></td><td>2020-02-03T07:33:33.668Z</td></tr><tr><td>bolvan</td><td><p>Изменение поведения опций сплита в tpws.</p>
<p>Теперь tpws в состоянии распознавать не только http, но и TLS ClientHello.<br>
split-http-req может применяться совместно с split-pos. Если блок данных является http запросом, будет применяться split-http-req, в ином случае split-pos.<br>
split-pos по умолчанию работает только с http и TLS ClientHello. Если вам нужно сплитать все остальное, укажите --split-any-protocol.<br>
–hostlist так же теперь работает со SNI из TLS ClientHello.</p>
<p>В config параметры TPWS_OPT_HTTP и TPWS_OPT_HTTPS удалены, вместо них единый TPWS_OPT.</p>
<p>Простой инсталятор и скрипты запуска адаптированы, чтобы более не запускать по отдельному инстансу на http и https. Добавлен режим tpws_hostlist_https.</p></td><td>2020-07-10T09:00:50.316Z</td></tr><tr><td>bolvan</td><td><p>В продолжение предыдущего.</p>
<p>В tpws добавлена возможность биндаться на множество адресов.<br>
Параметры --bind-addr и --bind-iface* начинают новый бинд. Следующие параметры --bind-wait*, --bind-linklocal относятся к последнему бинду.<br>
Если хотите указывать link-local явно в --bind-addr, то теперь к нему надо добавлять %interface_name.<br>
Например : fe80::1111:2222:3333:4444%br-lan<br>
Если явно не создан ни один бинд, то в целях совместимости параметров создается бинд по умолчанию на все адреса.</p>
<p>init скрипты адаптированы, чтобы запускать только 1 tpws в любых случаях. Ранее их могло быть до 6 шт.<br>
Особую проблему это представляло при использовании hostlist. Каждый инстанс подгружал свой hostlist. RAM это съедало до 6 раз больше, чем могло бы быть. На soho роутерах и листах от РКН это означало невозможность использования в такой конфигурации</p></td><td>2020-07-13T12:42:04.633Z</td></tr><tr><td>ValdikSS</td><td><p>8 posts were merged into an existing topic: <a href="/t/topic/726/2">Обсуждение</a></p></td><td>2020-10-19T19:51:16.649Z</td></tr><tr><td>bolvan</td><td></td><td>2020-10-19T17:57:19.141Z</td></tr><tr><td>bolvan</td><td><p>Сделана экспериментальная поддержка flow offloading в openwrt , включая простой инсталятор<br>
В openwrt flow offloading работает только глобально. Либо включено, либо выключено. nfqws не работает с включенным offloading.<br>
Скрипты zapret теперь сами в состоянии выборочно управлять трафиком, который идет на offload, отключая при этом системную установку. То есть в люси у вас будет чекбоксик выключен, но оффлоад на самом деле будет работать там, где он не мешает nfqws</p>
<p>Тестировалось только на software flow offloading, на hardware возможности проверить нет<br>
Если кто-то может проверить, буду благодарен.</p></td><td>2020-10-30T12:50:39.356Z</td></tr><tr><td>bolvan</td><td><p>Сделал рефакторинг системы управления режимами. Вместо впихивания нескольких опций в один строковый параметр MODE, эти опции теперь разделены по разным переменным.<br>
Поддержка keep alive в nfqws больше не требует custom скрипта. Она теперь вшита в основной функционал.</p>
<pre><code># CHOOSE OPERATION MODE
# MODE : nfqws,tpws,filter,custom
# nfqws : use nfqws
# tpws : use tpws
# filter : no daemon, just create ipset or download hostlist
# custom : custom mode. should modify custom init script and add your own code
MODE=tpws
# apply fooling to http
MODE_HTTP=1
# for nfqws only. support http keep alives. enable only if DPI checks for http request in any outgoing packet
MODE_HTTP_KEEPALIVE=0
# apply fooling to https
MODE_HTTPS=1
# none,ipset,hostlist
MODE_FILTER=none</code></pre></td><td>2020-11-01T11:31:29.070Z</td></tr><tr><td>bolvan</td><td><p>Добавлена проверка на подмену DNS в простой инсталятор install_easy.sh<br>
Инсталятор сам не будет решать проблему DNS за вас, но предупредит о возможной подмене</p></td><td>2020-11-26T12:33:45.656Z</td></tr><tr><td>bolvan</td><td><p>Было замечено, что virtualbox и vmware ломает большинство техник nfqws, если сеть настроена в режиме NAT.<br>
Принудительно заменяется TTL на ttl хоста, не проходят фейковые ретрансмиссии<br>
Необходимо настраивать VM в режиме bridge<br>
Ожидаемо так же не работает и GoodbyeDPI с --set-ttl</p></td><td>2021-02-03T10:41:50.799Z</td></tr><tr><td>bolvan</td><td><p>В nfqws добавлена возможность комбинирования режимов десинхронизации<br>
Режим 1-й фазы может быть fake,rst,rstack. Режим 2-й фазы может быть disorder,disorder2,split,split2.<br>
Пишем через запятую : --dpi-desync=fake,split<br>
Может быть полезно, когда у провайдера стоит не один DPI.<br>
–dpi-desync без  параметров раньше приравнивался к fake. Теперь это больше не поддерживается, требуется явное указание режима.</p></td><td>2021-02-03T18:05:10.188Z</td></tr><tr><td>bolvan</td><td><p>Ограниченная поддержка систем FreeBSD и OpenBSD<br>
работают mdig, ip2net, tpws<br>
на FreeBSD полностью работоспособны скрипты ipset/*.sh. Они заполняют ipfw lookup tables.<br>
тестировалось на FreeBSD 12.2 и OpenBSD 6.8. на значительно более старых скорее всего будут проблемы<br>
портирование nfqws напрямую невозможно. nfqueue в BSD отсутствует в принципе. нужно искать другой аналогичный механизм</p></td><td>2021-02-11T15:23:13.457Z</td></tr><tr><td>bolvan</td><td><p>Добил поддержку FreeBSD и OpenBSD.<br>
На замену nfqws пришел dvtws. Это nfqws, собираемый под divert sockets.<br>
Работает почти точно так же, как nfqws. Разница только в способах перенаправления трафика.<br>
ipfw команды или pf.conf вместо iptables</p>
<p>Экспериментально. Тестируйте, кто может.</p></td><td>2021-02-15T16:44:09.813Z</td></tr><tr><td>bolvan</td><td><p>Ограниченная поддержка MacOS.<br>
Яблочники там убрали все самое вкусное, поэтому dvtws и tpws в прозрачном режиме не завести.<br>
Работает tpws socks. Его можно сделать прозрачным через приложение Proxifier (на не совсем новых версиях macos ставит свой модуль ядра).<br>
Скрипты ipset/*.sh работают после установки через brew некоторых GNUшных программ взамен устаревшим имеющимся в macos.<br>
Описание в docs/bsd.txt</p></td><td>2021-02-19T15:17:33.823Z</td></tr><tr><td>bolvan</td><td><p>Прозрачный режим tpws в MacOS.<br>
Яблочники убрали net/pfvar.h, где находятся определения, необходимые для получения оригинального адреса в прозрачном режиме.<br>
Взял из старых версий яблочного SDK. Сработало. Они изменили некоторые структуры, поэтому вариант из BSD не работал.<br>
Но теперь это недокументировано, и запросто могут еще что-нибудь поубирать в будущих версиях.</p></td><td>2021-02-23T14:23:39.922Z</td></tr><tr><td>bolvan</td><td><p>Сделан install_easy.sh для MacOS<br>
Поддерживается весь стандартный набор, но только для tpws<br>
Internet sharing не поддерживается !! При его включении PF начинает функционировать странно.<br>
Редиректы не работают. При выключении все лишние anchor-ы убираются, состояние становится как до включения, но редиректы уходят в никуда.<br>
Лечится только через pfctl -f /etc/pf.conf.  В причинах пока не разобрался. Возможно, какие-то хитрости яблочников, выходящие за пределы стандартного поведения PF</p></td><td>2021-02-27T16:53:20.374Z</td></tr><tr><td>bolvan</td><td><p>В простой инсталятор внесен режим socks.</p>
<p>Редизайн выбора LAN и WAN интерфейсов на десктопных системах.<br>
В этом процессе есть ряд важных нюансов, которые нужно осознавать, включая фильтрацию по интерфейсам.<br>
Они описаны в readme в разделе “простая установка”</p></td><td>2021-03-06T09:11:03.735Z</td></tr><tr><td>bolvan</td><td><p>Новая схема дурения DPI, которые секут не только TLS ClientHello, но и ServerHello.<br>
Как же с этим бороться ? Сложно заставить сервер посылать не то, на что он запрограммирован.<br>
Лучшее решение было бы всем перейти на TLS 1.3, где ServerHello шифрован.<br>
Но переход идет вяло. Владельцы серверов годами остаются на давно настроенных и стабильных системах. Потому там может быть только TLS 1.2.<br>
Но кое-что все-таки сделать можно. Почему бы не возродить старую идею со сменой winsize, только наоборот ?<br>
В nfqws добавлен параметр --wssize=&lt;window_size&gt;[:&lt;scale_factor&gt;]<br>
Он позволяет менять window size и scale factor для сервера до тех пор, пока не будет отослан запрос, на который должен придти фрагментированный ответ, затем перестать менять winsize, чтобы вернуть скорость.<br>
Менять winsize и scale factor надо во всех пакетах от начала соединения до отсылки TLS ClientHello, иначе это не сработает на linux серверах.<br>
Типичное использование --wssize=1:6. scale_factor - это степень двойки, на которую умножается winsize.<br>
Чем он больше, тем потом будет выше скорость, однако если его сделать слишком большим, то не будет достигнута цель, а если слишком малым - потом будут тормоза.<br>
Для http такая схема бесполезна, поэтому заодно введена возможность в скриптах отдельно настраивать опции дурения nfqws для http и https</p>
<p><strong>Код:</strong></p>
<pre><code>NFQWS_OPT_DESYNC="--dpi-desync=fake --dpi-desync-ttl=0 --dpi-desync-fooling=badsum"
#NFQWS_OPT_DESYNC_HTTP="--dpi-desync=split --dpi-desync-ttl=0 --dpi-desync-fooling=badsum"
#NFQWS_OPT_DESYNC_HTTPS="--wssize=1:6 --dpi-desync=split --dpi-desync-ttl=0 --dpi-desync-fooling=badsum"
</code></pre>
<p>Для http берется NFQWS_OPT_DESYNC_HTTP, если он пустой - NFQWS_OPT_DESYNC<br>
Для https берется NFQWS_OPT_DESYNC_HTTPS, если он пустой - NFQWS_OPT_DESYNC<br>
Схема себя показала эффективной против ТСПУ, даже без fake, но со split</p></td><td>2021-03-20T10:50:21.731Z</td></tr><tr><td>bolvan</td><td><p>Режим десинхронизации synack. Отсылаем SYN,ACK перед SYN.<br>
Попытка убедить  DPI , что роли клиента и сервера перепутаны.<br>
Работает только если между атакующим девайсом и DPI нет NAT.<br>
Если верить geneva, возможно сработает в KZ (если уже не пофиксили)</p></td><td>2021-04-07T09:26:02.748Z</td></tr><tr><td>bolvan</td><td><p>Добавил поддержку openrc в install_easy.sh<br>
Проверено на nitrux и alpine.<br>
alpine - сильно обрезанная система, отсутствуют по умолчанию ip(6)tables<br>
Делать автоустановку не стал, чтобы не привязываться к специфической для обрезанной системы пакетной базе : apk add iptables ip6tables<br>
Должно работать и на gentoo при условии ручной установки ipset : emerge ipset</p>
<p>Более надежное определение systemd. Некоторые дистрибутивы оставляют systemctl и юниты, хотя systemd там отсутствует</p>
<p>Для облегчения интеграции с обрезанными системами и прошивками sysv init доработан до поддержки максимально спартанских условий. Может теперь работать с разными adduser/useradd или вовсе без них. Поддержка readonly root.<br>
Имея rw /opt, туда можно установить entware, необходимые проги, и все, что не дает использовать zapret на полную, это лишь отсутствующие модули ядра. Тут ничем помочь не могу.</p></td><td>2021-11-12T14:13:12.854Z</td></tr><tr><td>bolvan</td><td><p>Сделан собственный скрипт для автоматизации проверки стратегий обхода DPI через nfqws - blockcheck.sh<br>
Его следует запускать, когда любые инструменты обхода блокировок неактивны.<br>
Проверка подмены DNS убрана из install_easy.sh и перенесена в blockcheck.sh</p></td><td>2021-12-08T14:15:11.305Z</td></tr><tr><td>bolvan</td><td><p>Реализовано задание раздельных опций nfqws для http и https и для версий ip протоколов 4,6 :</p>
<pre><code class="lang-auto">NFQWS_OPT_DESYNC_HTTP="--dpi-desync=split --dpi-desync-ttl=0 --dpi-desync-fooling=badsum"
NFQWS_OPT_DESYNC_HTTPS="--wssize=1:6 --dpi-desync=split --dpi-desync-ttl=0 --dpi-desync-fooling=badsum"
NFQWS_OPT_DESYNC_HTTP6="--dpi-desync=split --dpi-desync-ttl=5 --dpi-desync-fooling=none"
NFQWS_OPT_DESYNC_HTTPS6="--wssize=1:6 --dpi-desync=split --dpi-desync-ttl=5 --dpi-desync-fooling=none"
</code></pre>
<p>Если какая-то из переменных NFQWS_OPT_DESYNC_HTTP/NFQWS_OPT_DESYNC_HTTPS не определена, берется значение NFQWS_OPT_DESYNC.<br>
Если какая-то из переменных NFQWS_OPT_DESYNC_HTTP6/NFQWS_OPT_DESYNC_HTTPS6 не определена, берется значение NFQWS_OPT_DESYNC_HTTP/NFQWS_OPT_DESYNC_HTTPS.<br>
Значит, если определено только NFQWS_OPT_DESYNC, то все 4 специализированные переменные берут это значение.<br>
Зачем это надо : вряд ли ttl будет одинаковым для ipv4 и ipv6. Если для ipv4 он окажется 9, то таким ttl вы вполне можете начать рубить сайты на ipv6</p>
<p>Скрипты всеми силами стараются минимизировать количество процессов nfqws, чтобы сохранить память. Для роутеров это важно, а если используется hostlist, то 4 процесса nfqws легко забьют и 256 Mb.  Если для разных вариантов используются одни параметры, то запускается только один процесс с ними.</p></td><td>2021-12-10T17:28:32.003Z</td></tr><tr><td>bolvan</td><td><p>В nfqws добавлен параметр --dpi-desync-ttl6, задающий отдельное значение для ipv6 hop limit.<br>
Если --dpi-desync-ttl6 не указан, то берется значение --dpi-desync-ttl. Чтобы отключить hop limit на ipv6 используйте --dpi-desync-ttl6=0.<br>
Параметр позволяет не запускать лишний процесс nfqws, когда стратегия обхода для ipv4 и ipv6 отличается лишь ttl.</p></td><td>2021-12-10T19:15:26.982Z</td></tr><tr><td>bolvan</td><td><p>В blockcheck.sh добавлена поддержка FreeBSD через фаервол ipfw<br>
Необходима загрузка модулей ipfw.ko и ipdivert.ko</p></td><td>2021-12-12T13:09:40.742Z</td></tr><tr><td>bolvan</td><td><p>В nfqws добавлена возможность настройки дурения badseq.<br>
Можно указать инкремент seq и ack_seq в виде знакового десятичного числа или знакового hex числа (1000,-1000,0x8000,-0x8000)</p>
<pre><code class="lang-auto">--dpi-desync-badseq-increment=&lt;int|0xHEX&gt; ; badseq fooling seq signed increment. default -10000
--dpi-desync-badack-increment=&lt;int|0xHEX&gt; ; badseq fooling ackseq signed increment. default -65000
</code></pre>
<p>Изменены значения по умолчанию. Раньше инкремент для обоих параметров был 0x80000000.<br>
Как оказалось, на некоторых провайдерах дурение badseq работает только в пределах ограниченного окна от текущего seq.</p></td><td>2021-12-26T14:28:40.719Z</td></tr><tr><td>bolvan</td><td><p>В nfqws добавлен параметр <code>--dpi-desync-fake-unknown=&lt;filename&gt;</code><br>
в нем указывается файл, который будет отсылаться в качестве фейка при<code> --dpi-desync=fake --dpi-desync-any-protocol</code><br>
и обработке не http запроса и не TLS ClientHello вместо стандартного пакета из 256 нулей</p>
<p>cutoff теперь имеет 3 варианта ограничителя<br>
n - номер пакета, начиная с 1<br>
d - номер пакета с данными, начиная с 1<br>
s - relative sequence number. он равен количеству переданных от клиента байтов + 1<br>
Отсечение происходит, если параметр равен или больше заданного значения.</p>
<pre><code class="lang-auto">--wssize-cutoff=[n|d|s]N               ; apply server wsize only to packet numbers (n, default), data packet numbers (d), relative sequence (s) less than N
--dpi-desync-cutoff=[n|d|s]N           ; apply dpi desync only to packet numbers (n, default), data packet numbers (d), relative sequence (s) less than N
</code></pre>
<p>Вкратце поясню зачем вся эта котовасья.<br>
Представьте , что настал очередной печальный день в истории рунета, и РКН решил заблокировать SMTP (тут можете подставить ваш любимый протокол, телеграм, допустим). Шлите почту только через авторизованные сервисы, где сидит тов. майор. SMTP протокол распознается и режется на ТСПУ.</p>
<p>Задача точно такая же, как и в случае http/https. Сделать так, чтобы DPI не понял, что это SMTP.<br>
Но так случилось, что абы чего DPI не пропускает. Левые протоколы тоже стали резать.<br>
Надо подсунуть что-то безобидное. Например, http запрос.<br>
И делать это до того момента, как начнется шифрованная фаза (ведь вы конечно же не будете слать почту без TLS ?)<br>
Обычно при отсылке почты через SMTP клиент выдает 2 открытых сообщения “EHLO servername” и “STARTTLS”, потом идет TLS handshake.</p>
<pre><code class="lang-auto">nfqws --qnum=250 --dpi-desync-any-protocol --dpi-desync-cutoff=d4 --dpi-desync=fake,split2 --dpi-desync-ttl=5 --dpi-desync-fake-unknown=/opt/zapret/files/fake/fake_http_req_example.bin
</code></pre>
<p>Будут обработаны первые 3 исходящих пакета TCP соединения с данными (то есть не будут в нумерации учтены пустые пакеты с ACK)<br>
Будут отосланы следующие сообщения : Будут отосланы следующие сообщения :</p>
<pre><code class="lang-auto">фейк : GET / HTTP/1.1 ... Host: iana.org
реал : EH
реал : LO mail.myserver.com
фейк : GET / HTTP/1.1 ... Host: iana.org
реал : ST
реал : ARTTLS
фейк : TLSClientHello от w3.org
реал : TLSClientHello от mail.myserver.com - первые 2 байта
реал : TLSClientHello от mail.myserver.com - остальные байты
</code></pre>
<p>после этого наступает состояние desync-cutoff (отсечение desync).<br>
nfqws больше не трогает это соединение, чтобы не замусоривать канал всякой ерундой и не снижать скорость</p>
<p>если добавите <code>--debug</code>, все станет понятно из лога nfqws</p>
<p>Разумеется, описанный сценарий пока чисто гипотетический, он служит лишь для иллюстрации техники. Будет ли это работать и с какими нюансами - покажет время.<br>
Если тупо забанят 25 порт или по IP startmail, protonmail, … - не сработает точно</p></td><td>2021-12-26T18:09:24.042Z</td></tr><tr><td>bolvan</td><td><p>Реализован задел для десинхронизации udp протоколов.<br>
Нацелено прежде всего всего на quic и dht, хотя далеко не только.<br>
Поддерживается только режим десинхронизации fake, поскольку фрагментация udp невозможна на транспортном уровне. Возможна только ip фрагментация - она пока не реализована.<br>
Fake нацелен на атаку на stateful DPI и бесполезен для stateless.</p>
<p>quic - новый протокол для доступа к сайтам по http3. Полностью шифрован. DPI вынужден будет расшифровывать непростым алгоритмом каждый пакет, чтобы хотя бы выдернуть SNI. Слишком дорого для stateless анализа и слишком опасно быть за-ddos-еным. Потому если ему скормить фейк, это может решить вопрос. Пока еще тестировать не на чем, но все впереди. Возможно, будут просто резать quic.</p>
<p>DHT бутстрап выполняется по UDP. Уже однажды пытались его заблокировать. Исследователи <a href="https://ntc.party/t/bittorrent-dht/1335">сообщали</a>, что если перед запросом скормить левый udp пакет с теми же source/dest port, то DPI отстает от UDP канала до истечения таймаута неактивности.</p>
<p>Задействование атаки на первый исходящий пакет данных :</p>
<pre><code class="lang-auto">iptables -t mangle -I POSTROUTING -p udp --dport 443 -j NFQUEUE --queue-num 200 --queue-bypass
nfqws --qnum=200 --dpi-desync-any-protocol --dpi-desync=fake --dpi-desync-ttl=5 --dpi-desync-cutoff=d2
</code></pre>
<p>Фулинг работает только по ttl и badsum. Другое к udp неприменимо.<br>
Можно заменить fake payload так : --dpi-desync-fake-unknown-udp=/opt/zapret/files/fake/fake_quic_initial_example.bin</p></td><td>2022-01-01T17:51:34.877Z</td></tr><tr><td>bolvan</td><td><p>Реализована фрагментация ipv4 и ipv6 на уровне ip : <code>--dpi-desync=ipfrag2</code><br>
К сожалению, это не прорыв, а скорее научный интерес. Современная сеть крайне враждебна к IP фрагментации.<br>
Фрагментированные пакеты часто застревают или пересобираются/перефрагментируются по пути.<br>
Часто их отбрасывают принимающие узлы, возможно как мера против ddos атак.<br>
Linux всегда пересобирает проходящие (forwarded) фрагментированные ipv6, если это возможно.<br>
Но как последнее средство для какой-то конкретной цели при соблюдении определенных условий теоретически может сработать<br>
Можно проверить с некоторой долей вероятности сработает ли обход на конкретном ресурсе через команду ping с размером пакета &gt;1472.<br>
Если обычный пинг ходит, а длинный не ходит, то фрагментация режется.</p>
<p>IP фрагментация доступна для tcp и udp протоколов.<br>
Возможно, с cutoff  хороший вариант для доступа к своему wireguard серверу в случае блокировки wireguard протокола, если провайдер и хостер не режут фрагменты</p></td><td>2022-01-03T09:44:25.264Z</td></tr><tr><td>bolvan</td><td><p>Обеспечена совместимость с последними версиями pfsense.<br>
Добавлены бинарики , собранные на FreeBSD 11 x64. Они должны работать на системах с ядром FreeBSD 11 и выше.<br>
Хотя они и запускаются как минимум на FreeBSD 10, бинарик dvtws нельзя использовать на этих системах !<br>
В коде присутствует условная компиляция , исправляющая баг/фичу FreeBSD 10.x и более старых.<br>
На более старых системах нужно собирать самостоятельно, при этом скорее всего придется обновлять и компилятор CLang не из репозитория. Эти системы уже out-of-support, могут быть даже проблемы с удаленными с серверов репозиториями. Лучше проапгрейдиться</p>
<p>Для запуска в pfsense требуется выполнить ряд действий, описанных в docs/bsd.txt</p></td><td>2022-01-23T08:55:15.721Z</td></tr><tr><td>bolvan</td><td><p>Только для ipv6 режим десинхронизации hopbyhop, fooling hopbyhop,hopbyhop2.</p>
<p>Fooling : добавляется ipv6 extenstion header “hop-by-hop options” во все фейки.<br>
В варианте hopbyhop2 добавляются 2 хедера, что является нарушением стандарта и гарантированно отбрасывается стеком протоколов во всех ОС. Один хедер hop-by-hop принимается всеми ОС, однако на некоторых каналах/провайдерах такие пакеты могут фильтроваться и не доходить. Расчет идет на то, что DPI проанализирует пакет с hop-by-hop, но он либо не дойдет до адресата всилу фильтров провайдера, либо будет отброшен сервером, потому что хедера два.</p>
<p>Desync: (не путать с fooling !) заключается в добавлении хедера “hop-by-hop options” во все оригинальные пакеты, попадающие под десинхронизацию. Здесь надо обязательно понимать, что добавление хедера увеличивает размер пакета, потому не может быть применено к пакетам максимального размера. Это имеет место при передаче больших сообщений. В случае невозможности отослать модицифированный пакет дурение будет отменено, пакет будет выслан в оригинале.<br>
Расчет идет на то, что DPI увидит 0 в поле next header основного заголовка ipv6 и не будет скакать по<br>
extension хедерам в поисках транспортного хедера. Таким образом не поймет, что это tcp или udp, и пропустит пакет без анализа. Возможно, какие-то DPI на это купятся.<br>
Может сочетаться с любыми режимами 2-й фазы.<br>
Например, “hopbyhop,split2” означает разбить tcp пакет на 2 сегмента, в каждый из них добавить hop-by-hop.<br>
При “hopbyhop,ipfrag2” последовательность хедеров будет : ipv6,hop-by-hop,fragment,tcp/udp.<br>
При поступлении пакета ipv4 режим hopbyhop игнорируется, но работает десинхронизация 2-й фазы, если таковая имеется.<br>
Может применяться как к tcp, так и к udp.</p></td><td>2022-02-01T17:47:18.466Z</td></tr><tr><td>bolvan</td><td><p>Добавлены режимы десинхронизации ipv6  destopt и ipfrag1.<br>
Заключаются в добавлении хедеров “destination options” и “fragment” (фрагмент единственный).<br>
В thc-ipv6 toolkit есть прога firewall6. Она пытается применить различные экзотические комбинации extension headers для проверки что пропускается, а что нет.<br>
hopbyhop часто режется. на 2 провайдерах проверил. destopt и единственный фрагмент обычно не режутся.<br>
остается понять как будут DPI воспринимать эти хедеры. будут ли они реагировать.<br>
пока не на чем проверить</p>
<p>По поводу режима ipfrag1 внимательно читать комментарии по IP фрагментации в readme.txt<br>
Обычно для ухода фрагментов ipv6 с локальной системы (OUTPUT) достаточно занести эти пакеты в notrack, но если фрагмент только один, fragment header может быть молча убран модулем nf_defrag_ipv6.<br>
Как повезет. На некоторых системах это случается, на некоторых нет. Гарантии может дать только загрузка модуля ip6table_raw с параметром raw_before_defrag=1.<br>
В openwrt нужно изменить файл вот так :</p>
<pre><code class="lang-auto">cat /etc/modules.d/ipt-raw6
ip6table_raw raw_before_defrag=1
</code></pre>
<p>и ребутнуть систему.</p></td><td>2022-02-05T12:49:41.324Z</td></tr><tr><td>bolvan</td><td><p>Проведен мощный рефакторинг скриптов запуска с целью поддержки nftables.<br>
Основная мотивация - переход будущей версии OpenWRT на firewall4+nftables.<br>
iptables уходят из мейнстрима openwrt, хотя могут быть доустановлены и использованы параллельно с nftables.<br>
Но есть и некоторая нерешаемая боль, связанная с nftables, о которой можно почитать здесь :</p>
<p><a href="https://github.com/bol-van/zapret/blob/master/docs/nftables_notes.txt">https://github.com/bol-van/zapret/blob/master/docs/nftables_notes.txt</a></p>
<p>nftables можно использовать на linux с достаточно новыми версиями ядра и утилиты nft.<br>
На OpenWRT nftables можно использовать, начиная с 21.xx. На более старых скорее всего будут проблемы.<br>
На OpenWRT 21.xx в nftables недоступен hardware flow offloading и не будет работать software flow offloading,если есть названия интерфейсов , начинающихся с цифры. Обычно это происходит, когда включен ipv6 и имеется 6to4,6in4. (fixed в snapshot версиях после 21.x)</p>
<p>На более новых системах, где уже основной фаервол firewall4+nftables, можно переключить zapret на iptables.<br>
Плюс - возможность использования больших ip lists на роутерах, минус - отсутствие поддержки flow offloading в любом варианте.</p>
<p>Что нужно понимать про скрипты запуска в OpenWRT : на системах с firewall3 при использовании iptables производится интеграция в fw3, как это было и раньше.<br>
/etc/init.d/zapret {start,stop} не трогают фаервол<br>
Вместо этого правила применяются через firewall include в /etc/config/firewall : /etc/firewall.zapret<br>
При использовании nftables, либо iptables на системах с firewall4, управление фаерволом происходит в init скрипте, как это делается на традиционных linux.<br>
В custom скриптах появилась отдельная функция для применения фаервола nft<br>
В openwrt custom теперь в iptables функции требуется и стартовать, и останавливать правила, как это сделано в традиционном linux.<br>
Функция стала полностью совместима с версией из sysv.<br>
Еще одно небольшое новшество - написан openrc адаптер для запуска sysv init.<br>
Оказалось, что некоторые системы с openrc (alpine linux), не автозапускают скрипты из /etc/init.d, если они не #!/sbin/openrc-run</p></td><td>2022-02-15T14:49:35.214Z</td></tr><tr><td>bolvan</td><td><p>Новости про nftables.</p>
<p>Выпустили, наконец, релиз nft 1.0.2.<br>
Пофиксена проблема с кавычками в flowtable</p>
<p>Боль с количеством RAM и nfset-ами по прежнему там. Создал баг в багзилле netfilter.</p></td><td>2022-02-23T11:05:26.773Z</td></tr><tr><td>bolvan</td><td><p>В связи сами знаете с чем банят известные ресурсы типа МОРДО КНИГИ<br>
Они используют QUIC. QUIC базируется на UDP и полностью зашифрован. Для DPI довольно сложно расшифровать QUIC , чтобы распознать домен. Потому начали на ТСПУ блочить QUIC. Видимо на все IP адреса, кроме whitelist (на ВКОНТАКТ QUIC не блокируется)<br>
Точно блокируется на youtube, google, facebook.</p>
<p>Я сделал поддержку UDP в nfqws упреждающе (см выше мои посты). Она сработала как надо.<br>
Вот это решает проблему :</p>
<pre><code class="lang-auto">iptables -t mangle -I POSTROUTING -p udp --dport 443 -m mark ! --mark 0x40000000/0x40000000 -m connbytes --connbytes-dir=original --connbytes-mode=packets --connbytes 1:3 -j NFQUEUE --queue-num 205 --queue-bypass
nfqws --qnum=205 ---dpi-desync=fake --dpi-desync-any-protocol --dpi-desync-cutoff=d4
</code></pre>
<p>Небольшое изменение в custom скриптах. Теперь необходимо указывать протокол “-p tcp” в фильтре zapret_custom_firewall<br>
Написан custom скрипт custom-nfqws-quic4all, который наследует режим MODE=nfqws и включает обход блокировки QUIC на все адреса, вне зависимости от фильтра ipset/hostlist.</p>
<p>Как оказалось, движок QUIC от chromium ловит не только UDP, но и ICMP ttl expired in transit, связанные со своими UDPшками. Они приходят от фейк-пакетов с низким TTL. Как только броузер славливает такой ICMP, сеанс считает порванным, дальше ничего не проходит. Mozilla этим НЕ страдает.<br>
Лечение : либо резать ttl expired in transit (нехорошо, поломаете трейсилки), либо отказаться от ttl fooling и заменить на любой другой, который сработает. Например, badsum.<br>
А можно вообще убрать fooling. В этом случае фейки будут доходить до сервера, но поскольку там трэш, они будут отбрасываться процессом веб сервера.<br>
Но если вы вдруг используете badsum и что-то на пути будет дропать пакеты с badsum (роутеры mediatek, заводские прошивки с linux), то обход не сработает<br>
Проще и надежнее убрать fooling</p></td><td>2022-03-04T16:55:44.703Z</td></tr><tr><td>bolvan</td><td><p>В последнее время начали банить крупные сайты по типу facebook. У них прыгающий IP. Если ресолвить <a href="http://facebook.com">facebook.com</a> и добавлять в ip list, то очень быстро перестает работать.<br>
Можно использовать некоторые листы с antifilter.download, где эта проблема решена (например, allyouneed). Если это не вариант, теперь можно самому закидывать дополнительные ip из скрипта IPSET_HOOK в конфиге. Этот скрипт вызывается при каждом заполнении ipset/nfset/table с параметром $1=имя таблицы. IP адреса или подсети должны быть выведены в stdout.<br>
Проблема пересечения интервалов в nfset решается автоматически. Об этом думать не нужно.<br>
Если задана переменная LISTS_RELOAD, IPSET_HOOK будет вызван 1 раз без параметров.</p>
<p>Пример как добавить в таблицу zapret все IPv4 адреса из автономной системы facebook/instagram :</p>
<pre><code class="lang-auto">#!/bin/sh

# AS32934 - facebook,instagram

AS="32934"

aslist()
{
    whois -h whois.radb.net -- "-i origin AS$1" | sed -nre 's/^route: *(.*)/\1/p'
}

[ "$1" = "zapret" ] &amp;&amp; {
    for as in $AS; do
        aslist $as
    done
}
</code></pre>
<p>Номера автономных систем перечисляются в переменной AS через пробел</p></td><td>2022-03-17T10:38:29.457Z</td></tr><tr><td>bolvan</td><td><p>реализовано определение протокола QUIC<br>
теперь не обязательно указывать --dpi-desync-any-protocol, чтобы работать по QUIC initial<br>
расшифровка QUIC initial и извлечение имени хоста, чтобы работал --hostlist, не поддерживается</p>
<p>К сожалению, было замечено на одном из провайдеров с ТСПУ, что начало QUIC сеанса устанавливается успешно, но пакеты вскоре внезапно перестают ходить, так что качество броузинга становится значительно хуже с таким QUIC, чем без него<br>
причины пока не ясны</p></td><td>2022-03-20T17:59:14.286Z</td></tr><tr><td>bolvan</td><td><p>Еще немного по поводу IP фрагментации.</p>
<p>При использовании iptables и NAT, похоже, что нет способа прицепить обработчик очереди после NAT.<br>
MASQUERADE является финальным таргетом, после него NFQUEUE не срабатывает.<br>
Проходящий пакет попадает в nfqws с source адресом внутренней сети, затем фрагментируется и уже не обрабатывается NAT.<br>
Так и уходит во внешюю сеть с src ip 192.168.x.x. Следовательно, метод не срабатывает.<br>
Видимо единственный рабочий метод - отказаться от iptables и использовать nftables.<br>
Хук должен быть с приоритетом 101 или выше.</p>
<p>В nftables скриптах от zapret  реализован перехват пакетов в NFQUEUE после NAT. Там это сделать достаточно просто.<br>
Но при этом если сгенерированные в nfqws пакеты не вводить в состояние notrack, то они заново процессятся NAT, происходит подмена src port. Потому добавлен хук predefrag, где эти пакеты помечаются как notrack. Дополнительно открывается путь , чтобы отсылать ipv6 фрагменты на ядрах 4.16+</p></td><td>2022-03-22T11:09:28.726Z</td></tr><tr><td>bolvan</td><td><p>Сделал расшифровку и анализ QUIC initial crypto frames в nfqws.<br>
Теперь работает hostlist и видно куда лезем в режиме --debug</p>
<p>Алгоритм довольно сложный. Требует крипто библиотеки. Чтобы не тащить тяжелые зависимости, минимально необходимый код понадерган из разных исходников + написано своего<br>
Нежатый бинарик вырос примерно на 20 кб</p></td><td>2022-03-25T14:17:14.926Z</td></tr><tr><td>bolvan</td><td><p>Реализованы режимы десинхронизации fakeknown и udplen<br>
fakeknown - это то же самое, что fake, только применяется исключительно к распознанным протоколам, даже если выставлено --dpi-desync-any-protocol. При этом вторая фаза десинхронизации применяется как раньше.<br>
udplen - режим, относящийся только к udp. Пакет увеличивается в размере, дополняясь нулями, на указанное в --dpi-desync-udplen-increment количество байт. По умолчанию - 2. Нацелено на обман DPI, ориентирующихся на размеры пакетов. Может сработать при условии, что протокол приложения не завязан жестко на размер udp payload и не обижается на изменение размера.<br>
К сожалению, обмануть таким образом статистическое застревание QUIC на ТСПУ не удается</p></td><td>2022-04-12T13:01:35.826Z</td></tr><tr><td>bolvan</td><td><p>Сделал инструкцию для быстрого старта</p>
<aside class="onebox githubblob" data-onebox-src="https://github.com/bol-van/zapret/blob/master/docs/quick_start.txt">
  <header class="source">

      <a href="https://github.com/bol-van/zapret/blob/master/docs/quick_start.txt" target="_blank" rel="noopener">github.com</a>
  </header>

  <article class="onebox-body">
    <h4><a href="https://github.com/bol-van/zapret/blob/master/docs/quick_start.txt" target="_blank" rel="noopener">bol-van/zapret/blob/master/docs/quick_start.txt</a></h4>


      <pre><code class="lang-txt">﻿Специально для тех, кто хочет побыстрее начать, но не хочет слишком углубляться в простыню readme.txt.

Предупреждение : не пишите в issue вопросы типа "как скопировать файл", "как скачать", "как запустить", ...
То есть все , что касается базовых навыков обращения с ОС linux. Эти вопросы буду закрывать сразу.
Если у вас подобные вопросы возникают, рекомендую не использовать данный софт или искать помощь где-то в другом месте.

Обход DPI является хакерской методикой. Под этим словом понимается метод, которому сопротивляется окружающая среда,
которому автоматически не гарантирована работоспособность в любых условиях и на любых ресурсах,
требуется настройка под специфические условия у вашего провайдера. Условия могут меняться со временем,
и методика может начинать или переставать работать, может потребоваться повторный анализ ситуации.
Могут обнаруживаться отдельные ресурсы, которые заблокированы иначе, и которые не работают или перестали работать.
Поэтому очень желательно иметь знания в области сетей, чтобы иметь возможность проанализировать техническую ситуацию.
Не будет лишним иметь обходные каналы проксирования трафика на случай, если обход DPI не помогает.

Будем считать, что у вас есть система на базе традиционного linux или openwrt.
Если у вас традиционный linux - задача обойти блокировки только на этой системе, если openwrt - обойти блокировки
для подключенных устройств. Это наиболее распространенный случай.

1) Скачайте zip архив проекта с github в /tmp, распакуйте его там,
либо клонируйте проект через : git clone --depth 1 https://github.com/bol-van/zapret
</code></pre>



  This file has been truncated. <a href="https://github.com/bol-van/zapret/blob/master/docs/quick_start.txt" target="_blank" rel="noopener">show original</a>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>
</td><td>2022-05-10T18:01:40.050Z</td></tr><tr><td>bolvan</td><td><p>nfqws теперь учитывает fwmark пакетов, попадающих к нему на обработку<br>
если в результате обработки пакета nfqws генерит свой пакет, его fwmark будет не 0x40000000, а 0x40000000 | &lt;original_fwmark&gt;</p>
<p>добавлен алгоритм лечения проблемы неверного выбора исходящего интерфейса для сгенерированных пакетов<br>
параметры --bind-fix4 и --bind-fix6<br>
лечение идет через вызов bind() на raw socket и setsockopt SO_BINDTODEVICE<br>
интерфейс назначения берется из NFQUEUE. куда оригинальный пакет уходил, туда и отправляем сгенеренные. это возможно как для OUTPUT, так и POSTROUTING<br>
linux не был бы linux-ом, если бы это не работало по разному для ipv4 и ipv6</p>
<p>в случае отсутствия опции bind-fix для соответствующего семейства ip отправка идет так, как было раньше. то есть система решает сама<br>
Проблема неверного выбора интерфейса может случиться, когда у вас несколько аплинков или присутствует policy routing на базе source ip.<br>
Причина - особенности маршрутизации пакетов , отправленных через raw sockets.<br>
Для сценария стандартного роутера LAN-WAN это не актуально</p></td><td>2022-05-15T13:02:01.336Z</td></tr><tr><td>bolvan</td><td><p>Удалось забороть хаотические зависания QUIC на ТСПУ при пробивке udp фейком.<br>
Всего лишь вместо нулей надо слать достаточно длинный пакет с quic short header вместо нулей.</p>
<pre><code class="lang-auto">nfqws --qnum=210 --user=daemon --dpi-desync-fwmark=0x40000000 --dpi-desync=fake --dpi-desync-fake-quic=/opt/zapret/files/fake/quic_short_header.bin
iptables -t mangle -I POSTROUTING -p udp --dport 443 -m connbytes --connbytes-dir=original --connbytes-mode=packets --connbytes 1:3 -m mark ! --mark 0x40000000/0x40000000 -j NFQUEUE --queue-num 210 --queue-bypass
</code></pre>
<p>Если использовать скрипты, то вариант custom с файлом custom-nfqws-quic4all<br>
и параметром config</p>
<blockquote>
<p>NFQWS_OPT_DESYNC_QUIC=“–dpi-desync=fake --dpi-desync-fake-quic=/opt/zapret/files/fake/quic_short_header.bin”</p>
</blockquote>
<p>Шифрованное содержимое особого значения не имеет, потому что DPI все равно не способен его расшифровать. Важен лишь первый байт, а точнее 2 его старших бита, и общая длина пакета.</p></td><td>2022-05-30T06:41:42.673Z</td></tr><tr><td>bolvan</td><td><p>Обновил инструкции по настройке policy routing openwrt → vps на базе wireguard .<br>
Добавлены правила nftables и способ их прикрутки для новых версий openwrt.<br>
Учтен новый статус wireguard. Он был включен в ядро linux 5.6.<br>
Так же обновлен вариант для redsocks.</p></td><td>2022-06-18T09:46:05.296Z</td></tr><tr><td>bolvan</td><td><p>Информация для любителей кинетиков на стоковой прошивке, где есть entware.</p>
<p>NDMS имеет проприетарное ядро, где в параллель со стандартными средствами маркировки mark и ct mark имеется в skbuff еще 1 марк - проприетарный ndmmark.<br>
Он был сделан, чтобы управлять логикой iptables, оставляя основной марк полностью свободным для юзера.</p>
<p>В частности, ndmmark используется для ограничения маскарада. Только пакеты с определенным ndmmark идут на маскарад. См <code>iptables-save -t nat</code></p>
<p>Если вы пытаетесь обойти блокировку quic через nfqws, то nfqws в этом случае дропает первый UDP пакет с quic initial, затем отправляет фейк своими средствами, ничего не зная о ndmmark. Первый пакет создает запись в conntrack, и она будет без маскарада.<br>
Все дальнейшие пакеты будут уходить на внешний интерфейс с source ip 192.168.x.x и дропаться провайдером.</p>
<p>Таким образом, вы заставляете nfqws работать не на обход, а на блокировку QUIC.<br>
И это даже иногда делает экспиренс лучше, если вдруг у провайдера DPI плохо блокирует QUIC, позволяя сеансу пройти дальше initial, а затем обрывая поток.<br>
Того же эффекта вы можете достичь просто блокируя порт udp:443 на выход. Для этого nfqws не нужен.</p>
<p>Для лечения посмотрите как устроены ваши цепочки и добавьте в  нужную цепочку маскарад на исходящий интерфейс WAN. Это может быть , например, ppp0, если у вас pppoe.</p>
<p>Если используются скрипты от zapret в варианте sysv, то можно добавить лечение в custom.<br>
Как-то так, но смотрите какие у вас реально цепочки (я за версии прошивок не ручаюсь), и какой внешний интерфейс.<br>
Пример лечащей добавки в скрипт custom-nfqws-quic4all</p>
<pre><code class="lang-auto">zapret_custom_firewall()
{
        # $1 - 1 - run, 0 - stop

        local MODE_OVERRIDE=nfqws
        local f
        local first_packets_only="-m connbytes --connbytes-dir=original --connbytes-mode=packets --connbytes 1:3"
        local desync="-m mark ! --mark $DESYNC_MARK/$DESYNC_MARK"

        zapret_do_firewall_rules_ipt $1

        f="-p udp --dport 443"
        fw_nfqws_post $1 "$f $desync $first_packets_only" "$f $desync $first_packets_only" $QNUM2

        # fix NDM kernel masquerade for nfqws
        ipta_add_del $1 _NDM_MASQ -t nat -o ppp0 -j MASQUERADE
}
</code></pre></td><td>2022-06-21T11:20:24.242Z</td></tr><tr><td>bolvan</td><td><p>Попал мне девайс Irbis TZ797 на android 8.1<br>
Если запускать обработчик очереди NFQUEUE на пакеты с интерфейса с сотовой сети, при этом кабель USB не воткнут (нет зарядки), то ядро очень быстро частично виснет, так что перестают работать тач и физические кнопки. При этом в броузере может продолжать анимироваться картинка.<br>
Выяснил, что проблема связана с UID. По умолчанию nfqws назначает себе UID 0x7FFFFFFF. Видимо, в более новых ведроидах (на 5 точно такого не было), процессы с такими UID могут ложиться в suspend, что блокирует обработку очереди , а на это завязаны вызовы ядра. И получаем то, что видим.<br>
Лекарство : nfqws --uid 1<br>
Перепробовал несколько вариантов из низких uid. Все не виснут.<br>
Для nfqws не нужны специальные uid 3003,3004,3005.<br>
Дело в том, что nfqws назначает себе привилегии cap_net_raw, cap_net_admin. Это необходимо для работы с nfqueue и raw sockets. Для android это является одним из разрешающих условий для доступа к сети, вне зависимости от uid.</p></td><td>2022-07-23T20:38:40.702Z</td></tr><tr><td>bolvan</td><td><p>Добавлена возможность усекания пакетов в режиме udplen (отрицательный increment). Более, чем до 1 байта, усечение не работает.<br>
Может быть полезно, когда прога добавляет паддинг в пакет, который ни на что не влияет, не проверяется, однако DPI проверяет размер пакета на минимальную длину.<br>
Усечение пакетов от стандартных программ может помочь.</p>
<p>Поддержка множественных листов включения и исключения.<br>
Альтернативой ipset является использование tpws или nfqws со списком доменов.<br>
Оба демона принимают неограниченное количество листов include (–hostlist) и exclude (–hostlist-exclude).<br>
Все листы одного типа обьединяются, и таким образом остаются только 2 листа.<br>
Прежде всего проверяется exclude list. При вхождении в него происходит отказ от дурения.<br>
Далее при наличии include list проверяется домен на вхождение в него. При невхождении в список отказ от дурения.<br>
Пустой список приравнивается к его отсутствию.<br>
В иных случаях происходит дурение.<br>
Нет ни одного списка - дурение всегда.<br>
Есть только exclude список - дурение всех, кроме.<br>
Есть только include список - дурение только их.<br>
Есть оба - дурение только include, кроме exclude.<br>
В системе запуска это обыграно следующим образом.<br>
Присутствуют 2 include списка :<br>
ipset/zapret-hosts-users.txt.gz или ipset/zapret-hosts-users.txt<br>
ipset/zapret-hosts.txt.gz или ipset/zapret-hosts.txt<br>
и 1 exclude список<br>
ipset/zapret-hosts-users-exclude.txt.gz или ipset/zapret-hosts-users-exclude.txt<br>
При режиме фильтрации MODE_FILTER=hostlist система запуска передает nfqws или tpws все листы, файлы которых присутствуют.<br>
Если вдруг листы include присутствуют, но все они пустые, то работа аналогична отсутствию include листа.<br>
Файл есть, но не смотря на это дурится все, кроме exclude.<br>
Если вам нужен именно такой режим - не обязательно удалять zapret-hosts-users.txt. Достаточно сделать его пустым.<br>
Поддомены учитываются автоматически. Например, строчка “<code>ru</code>” вносит в список “<code>*.ru</code>”. Строчка “<code>*.ru</code>” в списке не сработает.<br>
Список доменов РКН может быть получен скриптами ipset/get_reestr_hostlist.sh или ipset/get_antizapret_domains.sh - кладется в ipset/zapret-hosts.txt.gz.<br>
При фильтрации по именам доменов демон должен запускаться без фильтрации по ipset.<br>
tpws и nfqws решают нужно ли применять дурение в зависимости от хоста, полученного из протокола прикладного уровня (http, tls, quic).</p></td><td>2022-07-27T13:59:27.832Z</td></tr><tr><td>bolvan</td><td><p>Обнаружилось, что в openwrt на базе nftables на самой типичной конфигурации реального роутера (bridge lan/wlan), не срабатывала схема включения hardware offload. Причина - проверка, чтобы все компоненты моста поддерживали hw offload. wlan его не поддерживает. Сделал, чтобы из моста выбирались только поддерживающие интерфейсы, и только они добавлялись в flowtable.</p></td><td>2022-11-01T07:44:22.074Z</td></tr><tr><td>bolvan</td><td><p>Интересная проблема обнаружилась с hardware flow offloading.<br>
Стабильная версия openwrt 22.03 имеет ядро 5.10.<br>
Только начиная с ядра 5.13 автоматически определяются физические интерфейсы под мостами, pppoe и vlan. До этого надо было как-то вручную определять порты моста, базовый ethernet device под vlan или pppoe, и только их совать в flowtable.<br>
Для мостов и VLAN особых проблем нет. /sys/class/net/&lt;iface_name&gt; содержит ссылки lower_* на нужные интерфейсы. common/nft.sh из zapret умеет с таким работать. В случае hardware offload нижние девайсы определяются автоматом и засовываются в flowtable. Скрипт пытается туда засунуть и верхние, и нижние девайсы. Что проглотит - то и хорошо.</p>
<p>Но в случае pppoe не так все просто. Видимо нет очевидного способа определить что лежит под pppoe. В fw4 девайс определяется через вызов к netifd<br>
“ifstatus wan” возвращает<br>
“l3-device”: “pppoe-wan”<br>
“device”: “eth0”<br>
он и берется для засовывания в flow table</p>
<p>Пришлось и мне сделать нечто подобное. Но это работает только в openwrt.<br>
Если вдруг каким-то образом у вас старенькая традиционная linux система с hw offload, которая не умеет засовывать в hw offload   pppoe, то вам придется самому вписать добавление в flowtable физического интерфейса. Например, через hook. Впрочем, это весьма маловероятный случай<br>
Лучшим решением будет проапгрейдить ядро.</p>
<p>Другое изменение : для традиционных linux и macos в конфиге теперь можно использовать отдельный список IFACE_WAN6 для исходящих ipv6  интерфейсов.</p>
<p>В правила nft внесен тестовый счетчик для проверки flow offload</p>
<pre><code class="lang-auto">nft list chain inet zapret  flow_offload

table inet zapret {
        chain flow_offload {
                oifname @wanif tcp dport 80 ip daddr @zapret ip daddr != @nozapret return comment "direct flow offloading exemption"
                oifname @wanif tcp dport 443 ct original packets 1-4 ip daddr @zapret ip daddr != @nozapret return comment "direct flow offloading exemption"
                meta l4proto { tcp, udp } flow add @ft
                meta l4proto { tcp, udp } counter packets 1227 bytes 75527 comment "if offload works here must not be too much traffic"
        }
}
</code></pre>
<p>Посмотрите текущий counter. Запустите speedtest. counter не должен увеличиваться сильно. Не должно быть никаких увеличивающихся мегабайтов.<br>
Если они там есть - offload не работает.<br>
Посмотрите какие интерфейсы занесены в flowtable.<br>
Для software offload должны быть высокоуровневые интерфейсы (мосты, pppoe, vpn, …). Для hardware могут потребоваться лежащие под ними низкоуровневые интерфейсы (lan1, lan2, lan3, lan4). Общее правило - должны быть и входящие, и исходящие интерфейсы.<br>
Если там их нет - значит что-то работает не так.</p>
<pre><code class="lang-auto">nft list flowtable inet zapret ft
table inet zapret {
        flowtable ft {
                hook ingress priority filter - 1
                devices = { br-lan, wan }
        }
}
</code></pre></td><td>2022-11-15T12:43:52.525Z</td></tr><tr><td>bolvan</td><td><p>Решил сделать свой сервис по обработке выгрузки реестра РКН.<br>
Главная мотивация - отсутствие ipv6 в решениях от antifilter.network<br>
Для получения листов используйте get_reestr_preresolved.sh и get_reestr_preresolved_smart.sh<br>
Подробности тут <a href="https://rutracker.org/forum/out.php?url=https%3A%2F%2Fgithub.com%2Fbol-van%2Fzapret%2Fissues%2F130&amp;p=84022606&amp;t=5171734&amp;f=616&amp;u=29533471">https://github.com/bol-van/zapret/issues/130</a></p></td><td>2022-12-11T10:13:26.600Z</td></tr><tr><td>bolvan</td><td><p>В mdig добавлены опции --log-resolved и --log-failed<br>
для создания логов успешных и провальных доменов</p>
<p>На <a href="http://list.nethub.fi">http://list.nethub.fi</a> появились листы проверенных доменов из реестра РКН, которые ресолвятся по ipv4, ipv6 и “ipv4 или ipv6” .<br>
Как оказалось, примерно половина доменов из реестра не ресолвятся никак, фактические являясь трэшем</p></td><td>2023-01-06T08:52:50.080Z</td></tr><tr><td>bolvan</td><td><p>Блокировка QUIC все больше начала оформляться у провайдеров во что-то законченно-логичное вместо хаотических попыток что-то там заткнуть или заткнуть вообще весь протокол или порт.</p>
<p>На большинстве провайдеров сделана блокировка по SNI (идет расшифровка на DPI) как на ipv4, так и на ipv6, по списку заблокированных доменов.<br>
Однако, модули распознавания QUIC initial видимо еще старые и кривые, потому могут сечь, например, curl с nghttp3 и chromium, но не сечь curl с quiche или firefox, потому блокировка может быть не видна с первого взгляда.<br>
Как правило блокировки QUIC по SNI - stateful, поскольку анализировать каждый пакет в соединении чревато гигабитным флудом и залеганием DPI в bypass. Расшифровка QUIC - непростая операция. Это значит, что если DPI в сеансе UDP первым пакетом не видит ничего осудительного, то все остальное не анализируется.</p>
<p>Итак, QUIC внесен полностью в основные скрипты и инсталятор с поддежкой фильтрации по ipset/hostlist, аналогично http/https.<br>
Особого смысла менять режим десинхронизации нет. Просто выбираете MODE=nfqws и отвечаете yes или no на “enable QUIC”. Дальше все само. По понятным причинам QUIC работает только с nfqws и не работает с tpws.</p>
<p>К сожалению, пока внести автопроверку на QUIC в blockcheck не представляется возможным, поскольку поддержка quic экспериментальна, и стандартные курлы http3 не поддерживают.<br>
Потому можно посмотреть по F12 в броузере на <a href="http://facebook.com">facebook.com</a> перешел ли он на HTTP3 после включения обхода.<br>
Или лучше всего через curl --http3-only или посмотреть в wireshark udp port 443.<br>
Прекомпиленые бинарики с поддержкой http3 можно загуглить для linux x86_64 и windows.<br>
Если не обходится - выключайте.</p></td><td>2023-07-02T16:13:02.747Z</td></tr><tr><td>bolvan</td><td><p>Неплохой проект <a href="https://ntc.party/t/byedpi/4683/1" class="inline-onebox">ByeDPI</a><br>
Работает как прокси и не требует дополнительных привилегий в системе, тем не менее реализует режимы disorder2 и fake (последний может быть ненадежно).<br>
Тем не менее содержит очень интересные идеи, до которых я бы раньше не догадался. Спасибо разработчику.<br>
Вариант --disorder перенесен в tpws, обновлен blockcheck.<br>
tpws имеет преимущества : работает в MacOS и не требует привилегий в режиме socks<br>
Режим работает не так, как хотелось бы, в FreeBSD, OpenBSD и Windows вследствие особенностей ядра.</p>
<p>От переноса fake в tpws пока воздержался. Необходимо тестировать как он себя поведет на разных системах, поскольку используются потенциально ненадежные хаки.</p></td><td>2023-07-03T12:39:06.539Z</td></tr><tr><td>bolvan</td><td><p>Добавил в nfqws определение wireguard handshake initiation.<br>
По крайней мере с тем блоком, что был недавно включен на ТСПУ, больше не потребуется --dpi-desync-any-protocol.<br>
Что касается openvpn, то глубоко не изучал особенности его блокировки. Включат опять - будут смотреть имеет ли смысл добавлять определение протокола в nfqws</p>
<p>Заодно проверил работает ли увеличение длины пакета с wireguard. Не работает. Wg отбрасывает эти пакеты, так что --dpi-desync=udplen для wg не подходит. А было бы здорово, если бы работал. Диссектор из NDPI четко проверяет udplen==148</p></td><td>2023-08-12T06:59:35.609Z</td></tr><tr><td>bolvan</td><td><p>Сегодня стали блочить DHT.<br>
Блокируются исходящие udp пакеты с длиной 101…399 , начинающиеся с “d1” и заканчивающиеся на “e”, с номерами src port 1025…65536.  &lt;=1024 не блокируются.<br>
Блокировка stateful, но только в одну сторону. После пробивки с одной стороны аналогичные пакеты с другой стороны ходить не начинают.<br>
Возможно, это связано с несколькими ТСПУ на пути : у исходящего провайдера, у входящего провайдера и на магистрали.<br>
Некоторые DHT все же доходят с разных IP адресов. Предполагаю, что не на всех путях установлен ТСПУ, который считает пакет исходящим. Бывает не доходит даже из-за бугра, где нет ТСПУ (но может быть на магистрали).</p>
<p>Создан custom script custom-nfqws-dht4all.</p>
<p>nftables фильтр : ct original packets 1 meta length 109-407 meta l4proto udp <span class="mention">@th</span>,64,16 0x6431<br>
iptables фильтр : -p udp -m connbytes --connbytes-dir=original --connbytes-mode=packets --connbytes 1:1 -m length --length 109:407 -m u32 --u32 ‘0&gt;&gt;22&amp;0x3C@8&gt;&gt;16=0x6431’<br>
ip6tables фильтр : -p udp -m connbytes --connbytes-dir=original --connbytes-mode=packets --connbytes 1:1 -m length --length 109:407 -m u32 --u32 ‘48&gt;&gt;16=0x6431’<br>
nfqws : --dpi-desync=fake --dpi-desync-any-protocol --dpi-desync-cutoff=d2 --dpi-desync-ttl=5</p>
<p>(длина считается вместе с udp заголовком 8 байт)</p>
<p>Возможно, ситуация связана с выборами, и скоро отключат, но надо быть готовым</p></td><td>2023-09-06T09:30:42.160Z</td></tr><tr><td>bolvan</td><td><p>Сделал поддержку параметра nfqws --dpi-desync-udplen-pattern.<br>
Можно задать файл или hex строку, которой добиваются udp пакеты при режиме десинхронизации udplen.<br>
Теперь везде, где nfqws раньше читал файл, можно указывать как имя файла, так и HEX строку, которая начинается с 0x</p></td><td>2023-09-07T11:07:28.090Z</td></tr><tr><td>bolvan</td><td><p>Сделал распознавание протокола DHT. Распознается как udp, начинающийся с d1, кончающийся e (соответствует фильтру ТСПУ).<br>
Новый режим десинхронизации tamper.<br>
Этот режим предназначен для корректной модификации известных пейлоадов, чтобы DPI их не распознавал, но пейлоад оставался корректным и нес ту же смысловую нагрузку.<br>
Для DHT это вставление строки “2:001:x” после “d” в начале. Вставляется ничего не значащий элемент в bencode dictionary с длиной ключа 2, вместо 1. Таким образом dht начинается с d2.</p>
<p>Этот метод может помочь, если вдруг сделают блокировку stateless. fake против stateless не работает</p></td><td>2023-09-07T17:28:03.918Z</td></tr><tr><td>bolvan</td><td><p>Нашел средство обьединять подсети.<br>
ip2net работает только с отдельными IP адресами, пропуская подсети как есть.<br>
Это позволило существенно сократить размер листов с <a href="http://list.nethub.fi">list.nethub.fi</a><br>
Для роутеров с nft и обьемом памяти &lt;256 Mb  это крайне актуально</p></td><td>2023-09-20T06:28:16.404Z</td></tr><tr><td>bolvan</td><td><p>Принципиально новый способ дурения через tpws : --tlsrec<br>
Разбиение ClientHello на уровне TLS Record. Одну TLS record нарезаем на две в одном TCP сегменте (при желании потом и это можно разделить на 2 tcp сегмента через --split-pos и перепутать порядок пакетов --disorder).<br>
Режем или прямо по хосту в SNI, что исключает бинарный поиск паттерна без парсинга протокола, или на указанной байтовой позиции.<br>
Говорят, работает даже на китайском фаерволе.</p>
<p>Метод хороший, но ломает различные ddos защиты, потому где-то 10% сайтов обломаются. gosuslugi не работают. Без фильтра использовать нецелесообразно.</p>
<p>В России не работает на TLS 1.2, поскольку rdp-шный DPI еще смотрит на сертификат из ответа сервера TLS ServerHello. Это можно обойти через комбо с nfqws --wssize.</p>
<p>Удивительно, но многие серьезные сайты все еще не поддерживают TLS 1.3<br>
Среди них сбер, другие банки, гос услуги, <a href="http://mail.ru">mail.ru</a><br>
Среди заблокированных точно не поддерживает <a href="http://lostfilm.tv">lostfilm.tv</a></p></td><td>2023-10-12T09:46:30.573Z</td></tr><tr><td>bolvan</td><td><p>Вышел недавно openwrt 23.05.<br>
Принципиальных изменение по сравнению с 22.03.05 в нем не так много.<br>
Но есть одно, касающееся zapret.<br>
openwrt перешел по умолчанию на mbedtls вместо wolfssl.  mbedtls не поддерживает TLS1.3<br>
Следовательно при использовании штатного curl не работают методы проверки TLS 1.3 в blockcheck. Сам blockcheck предупреждает, что libcurl не поддерживает TLS1.3.</p>
<p>Что можно сделать для решения этой проблемы :</p>
<ol>
<li>Взять статический бинарик с  <a href="https://github.com/bol-van/bins" class="inline-onebox">GitHub - bol-van/bins: precompiled static binaries for android</a><br>
и заменить им родной.  если у вас почти нет места, можно записать его в какую-нибудь директорию в /tmp, затем добавить в PATH в начало эту директорию. временное решение только для проверки blockcheck</li>
<li>Пересобрать openwrt с libcurl, базированном на другой tls library. Например, openssl. Заодно поискать какие пакеты зависят от wolfssl или mbedtls и заменить там preferred tls library. Так можно попытаться вообще убрать mbedtls, чтобы он не занимал места.</li>
<li>Не пересобирать весь openwrt, а взять SDK одноименной версии, собрать libcurl с другой TLS library, взять из bin ipk пакеты только самого libcurl и его зависимости , установить на openwrt, замещая текущие. Проверить, что ничего не сломалось.</li>
<li>Не запускать blockcheck на роутере, а вместо этого использовать виртуалку с linux, отключив предварительно zapret на роутере. Не забыть, что найденные TTL следует уменьшить на 1, чтобы стратегия была корректной для рутера.</li>
</ol>
<p>TLS1.2 - более жесткий случай. Если какие-то стратегии работают на 1.2, они будут работать и на 1.3.<br>
Проверка 1.3 нужна только, если не удалось найти рабочий вариант для 1.2. Чтобы хоть как-то работало.</p></td><td>2023-10-23T06:45:52.630Z</td></tr><tr><td>bolvan</td><td><h2><a name="autohostlist-1" class="anchor" href="#autohostlist-1"></a>Режим фильтрации autohostlist</h2>
<p>Этот режим позволяет проанализировать как запросы со стороны клиента, так и ответы от сервера.<br>
Если хост еще не находится ни в каких листах и обнаруживается ситуация, похожая на блокировку,<br>
происходит автоматическое добавление хоста в список autohostlist как в памяти, так и в файле.<br>
nfqws или tpws сами ведут этот файл.<br>
Чтобы какой-то хост не смог попась в autohostlist используйте hostlist-exclude.<br>
Если он все-же туда попал - удалите запись из файла вручную и перезапустите tpws/nfqws<br>
или дайте им сигнал HUP, чтобы они перечитали листы.<br>
tpws/nfqws сами назначают владельцем файла юзера, под которым они работают после сброса привилегий, чтобы иметь возможность обновлять лист.</p>
<p>В случае nfqws данный режим требует перенаправления в том числе и входящего трафика.<br>
Крайне рекомендовано использовать ограничитель connbytes, чтобы nfqws не обрабатывал гигабайты.<br>
По этой же причине не рекомендуется использование режима на BSD системах. Там нет фильтра connbytes.</p>
<p>Как вообще могут вести себя DPI, получив “плохой запрос” и приняв решение о блокировке :</p>
<ol>
<li>Зависание : просто отмораживается, блокируя прохождение пакетов по TCP каналу.</li>
<li>RST : отправляет RST клиенту и/или серверу</li>
<li>Редирект : (только для http) отправляет редирект на сайт-заглушку</li>
<li>Подмена сертификата : (только для https) полный перехват TLS сеанса с попыткой всунуть что-то<br>
свое клиенту. Применяется нечасто, поскольку броузеры на такое ругаются.</li>
</ol>
<p>nfqws и tpws могут сечь варианты 1-3, 4 они не распознают.<br>
Всилу специфики работы с отдельными пакетами или с TCP каналом tpws и nfqws распознают эти ситуации по-разному.<br>
Что считается ситуацией, похожей на блокировку :</p>
<ol>
<li>[nfqws] Несколько ретрансмиссий первого запроса в TCP сеансе, в котором имеется hostname.</li>
<li>[nfqws,tpws] RST, пришедший в ответ на первый запрос с хостом.</li>
<li>[nfqws,tpws] HTTP редирект, пришедший в ответ на первый запрос с хостом, на глобальный адрес с доменом 2 уровня, не совпадающим с доменом 2 уровня оригинального запроса.</li>
<li>[tpws] закрытие соединения клиентом после отправки первого запроса с хостом, если не было на него ответа со стороны сервера. Это обычно случается по таймауту, когда нет ответа (случай “зависание”).</li>
</ol>
<p>Чтобы снизить вероятность ложных срабатываний, имеется счетчик ситуаций, похожих на блокировку.<br>
Если за определенное время произойдет более определенного их количества, хост считается заблокированным и заносится в autohostlist. По нему сразу же начинает работать стратегия по обходу блокировки.</p>
<p>На практике работа с данным режимом выглядит так.<br>
Первый раз пользователь заходит на сайт и получает заглушку, сброс соединения или броузер подвисает, вываливаясь по таймауту с сообщением о невозможности загрузить страницу.<br>
Надо долбить F5, принуждая броузер повторять попытки. После некоторой попытки сайт<br>
начинает работать, и дальше он будет работать всегда.</p>
<p>С этим режимом можно использовать техники обхода, ломающие значительное количество сайтов.<br>
Если сайт не ведет себя как заблокированный, значит обход применен не будет.<br>
В противном случае терять все равно нечего.<br>
Однако, могут быть временные сбои сервера, приводящие к ситуации, аналогичной блокировке.<br>
Могут происходит ложные срабатывания. Если такое произошло, стратегия может начать ломать<br>
незаблокированный сайт. Эту ситуацию, увы, придется вам контролировать вручную.<br>
Заносите такие домены в <code>ipset/zapret-hosts-user-exclude.txt</code>, чтобы избежать повторения.</p>
<p>Скрипты zapret ведут autohostlist в <code>ipset/zapret-hosts-auto.txt</code>.<br>
install_easy.sh при апгрейде zapret сохраняет этот файл.<br>
Режим autohostlist включает в себя режим hostlist.<br>
Можно вести <code>ipset/zapret-hosts-user.txt</code>, <code>ipset/zapret-hosts-user-exclude.txt</code>.</p></td><td>2023-10-26T12:23:12.876Z</td></tr><tr><td>bolvan</td><td><p>Удалось ускорить blockcheck. Для этого требуется sleep с возможностью спать меньше секунды.<br>
В openwrt этого по умолчанию нет. На новых openwrt, где есть ucode, удалось извернуться. Для более старых требуется установка coreutils-sleep. Внесено предолжение по установке coreutils-sleep в install_easy.sh в случае  необходимости</p>
<p>Собственно, зачем нужен микро sleep.<br>
Проверка осуществляется так. Сначала устанавливается общее правило перенаправления трафика, которое не меняется на время тестирования всего блока параметров.<br>
При тестировании каждого параметра запускается nfqws/dvtws или tpws, параметр тестируется , затем nfqws/dvtws или tpws прибиваются.<br>
Им требуется какое-то время для инициализации. Если послать запрос раньше, в случае tpws получим полный облом - connection refused, в случае nfqws/dvtws  если система достаточно медленная, получим отброс первого пакета и ретрансмиссию.  Это все ведет к задержкам при тестировании каждого параметра. На деле ждать 1 секунду избыточно. Вполне достаточно 100 мсек. Но вот беда, в openwrt бизибокс, собранный без поддержки float sleep и без usleep, и нечем вызвать syscall nanosleep().<br>
Благо, ucode все-таки это может. Есть функция запуска процесса с таймаутом. Но ucode появился вместе с fw4 в 22-й версии openwrt. В более старых нет. Потому там надо устанавливать coreutils-sleep, который умеет спать с дробями секунды. Благо, он весит всего 40-50K. Зато блокчек в разы шустрее пробегает.<br>
Используется 4 варианта поспать мало. Если никакой из них не сработал - спим 1 секунду</p></td><td>2023-10-31T09:30:34.875Z</td></tr><tr><td>bolvan</td><td><p>В tpws и nfqws добавлена возможность логгинга положительных решений по autohostlist.<br>
Можно разобраться когда и по какой причине что-то попало в лист.<br>
Через скрипты проведено как переменная AUTOHOSTLIST_DEBUGLOG.<br>
При значении “1” ведется лог в ipset/zapret-hosts-auto-debug.log</p>
<details>
<summary>
Пример</summary>
<pre><code class="lang-auto">09.11.2023 12:42:39 : dostfilms.site : incoming RST
09.11.2023 12:42:39 : dostfilms.site : fail counter 1/2
09.11.2023 12:42:39 : dostfilms.site : incoming RST
09.11.2023 12:42:39 : dostfilms.site : fail counter 2/2
09.11.2023 12:42:39 : dostfilms.site : adding
09.11.2023 12:43:30 : sun9-33.userapi.com : incoming RST
09.11.2023 12:43:30 : sun9-33.userapi.com : fail counter 1/2
09.11.2023 12:43:31 : sun9-75.userapi.com : incoming RST
09.11.2023 12:43:31 : sun9-75.userapi.com : fail counter 1/2
09.11.2023 12:43:31 : sun9-61.userapi.com : incoming RST
09.11.2023 12:43:31 : sun9-61.userapi.com : fail counter 1/2
09.11.2023 14:20:04 : sun9-46.userapi.com : incoming RST
09.11.2023 14:20:04 : sun9-46.userapi.com : fail counter 1/2
09.11.2023 14:20:04 : sun9-28.userapi.com : incoming RST
09.11.2023 14:20:04 : sun9-28.userapi.com : fail counter 1/2
09.11.2023 14:20:04 : sun9-5.userapi.com : incoming RST
09.11.2023 14:20:04 : sun9-5.userapi.com : fail counter 1/2
09.11.2023 14:21:53 : sun9-33.userapi.com : incoming RST
09.11.2023 14:21:53 : sun9-33.userapi.com : fail counter 1/2
09.11.2023 14:25:08 : hd-rezka.pro : redirect to another domain
09.11.2023 14:25:08 : hd-rezka.pro : fail counter 1/2
09.11.2023 14:25:11 : hd-rezka.pro : redirect to another domain
09.11.2023 14:25:11 : hd-rezka.pro : fail counter 2/2
09.11.2023 14:25:11 : hd-rezka.pro : adding
09.11.2023 14:25:43 : films1080.best : redirect to another domain
09.11.2023 14:25:43 : films1080.best : fail counter 1/2
09.11.2023 14:25:44 : films1080.best : redirect to another domain
09.11.2023 14:25:44 : films1080.best : fail counter 2/2
09.11.2023 14:25:44 : films1080.best : adding
09.11.2023 14:29:48 : tv1.lordfilm.black : redirect to another domain
09.11.2023 14:29:48 : tv1.lordfilm.black : fail counter 1/2
09.11.2023 14:29:49 : tv1.lordfilm.black : redirect to another domain
09.11.2023 14:29:49 : tv1.lordfilm.black : fail counter 2/2
09.11.2023 14:29:49 : tv1.lordfilm.black : adding
</code></pre>
</details>
<p>Из примера видно, что разные поддомены незаблокированного <a href="http://userapi.com">userapi.com</a> периодически дают RST. Это можно списать на перегруженность серверов. Устойчивой картины нет, поэтому порог срабатывания 2 фейла за 60 секунд не достигается. Домены не заносятся в лист.<br>
Другие домены дают устойчивую картину, потому заносятся в лист<br>
Порогами срабатывания можно играться</p>
<details>
<summary>
Другой пример</summary>
<pre><code class="lang-auto">09.11.2023 12:41:23 : www.kinozone.online : tcp retrans threshold reached
09.11.2023 12:41:23 : www.kinozone.online : fail counter 1/2
09.11.2023 12:41:26 : www.kinozone.online : tcp retrans threshold reached
09.11.2023 12:41:26 : www.kinozone.online : fail counter 2/2
09.11.2023 12:41:26 : www.kinozone.online : adding
09.11.2023 12:42:03 : hd-rezka.pro : tcp retrans threshold reached
09.11.2023 12:42:03 : hd-rezka.pro : fail counter 1/2
09.11.2023 14:24:05 : hd-rezka.pro : tcp retrans threshold reached
09.11.2023 14:24:05 : hd-rezka.pro : fail counter 1/2
09.11.2023 14:24:06 : hd-rezka.pro : tcp retrans threshold reached
09.11.2023 14:24:06 : hd-rezka.pro : fail counter 2/2
09.11.2023 14:24:06 : hd-rezka.pro : adding
09.11.2023 14:28:59 : kinogo.io : tcp retrans threshold reached
09.11.2023 14:28:59 : kinogo.io : fail counter 1/2
09.11.2023 14:29:00 : kinogo.io : tcp retrans threshold reached
09.11.2023 14:29:00 : kinogo.io : fail counter 2/2
09.11.2023 14:29:00 : kinogo.io : adding
</code></pre>
</details>
<p>Из этого примера видно, что провайдер не шлет RST, а отмораживается на плохие домены. Сеансы виснут. Клиент пытается слать ретрансмиссии, не получая ACK. Достигнув порога в 3 ретрансмиссии происходит срабатывание события “похоже на блокировку”. 2 раза так подвисли за 60 секунд - занесли в лист<br>
К hd-rezka.pro пробовали обращаться в 12:42. Страница подвисла, но передалбливаться не стали. Долбанулись только 1 раз и расслабились. Порог достигнут не был. Потом в 14:24 начали долбиться более настойчиво, что вызвало срабатывание.</p></td><td>2023-11-09T09:22:50.449Z</td></tr><tr><td>bolvan</td><td><p>Обратили мое внимание на штуку, о которой знать не знал.<br>
chrome://flags   kyber<br>
Это постквантовая штука для TLS , которая раздувает ClientHello до 2 TCP frames.<br>
Следовательно, nfqws ломается. Он в принципе не занимается реассемблингом TCP frames. А DPI занимается и корректно блокирует.<br>
Если вдруг хромисты начнуть дефолтить эту фичу, придется доделывать nfqws</p>
<p>Кстати, это так же пинок в адрес GoodbyeDPI<br>
У него та же проблема. Или нет ? Если вдруг он не парсит целую TLS запись, а ищет паттерн, то ему все равно.<br>
НО. Chrome засовывает SNI в разные места ClientHello. Попадает то в 1-й пакет, то во 2-й. 2-й пакет вообще не содержит сколько нибудь вразумительного начала.</p>
<p>Предполагаемый способ решения проблемы в nfqws.</p>
<ol>
<li>Разрешить partial ClientHello. Это поможет проанализировать 1-й пакет, даже если он порезан на середине. Если SNI находится там, вопрос решен</li>
<li>Если все-же SNI находится не в 1-м сегменте, то придется делать реассемблинг до тех пор, пока не обнаружится SNI. И тогда делать desync не на 1-й пакет , а на тот, где находится SNI. Ведь это и есть цель.  Делать на все не есть хорошо, потому что есть фильтры hostlist, и вообще неясно есть ли SNI в TLS сообщении. Но что тогда ? Запоминать все пакеты, пока не будет возможность принять решение, и потом их выплевывать ? Можно, хотя и сложновато</li>
</ol>
<p>в tpws этой проблемы ожидаемо нет</p></td><td>2023-11-12T08:40:31.466Z</td></tr><tr><td>bolvan</td><td><p>Сделана поддержка работы с TLS ClientHello, размазанными на несколько пакетов</p>
<p>РЕАССЕМБЛИНГ TCP<br>
nfqws поддерживает реассемблинг некоторых видов tcp запросов.<br>
На текущий момент это TLS ClientHello. Он бывает длинным, если в chrome включить пост-квантовую<br>
криптографию tls-kyber, и занимает как правило 2 пакета.<br>
chrome рандомизирует фингерпринт TLS. SNI может оказаться как в начале, так и в конце, то есть<br>
попасть в 1 или 2 пакет. stateful DPI обычно реассемблирует запрос целиком, и только потом<br>
принимает решение о блокировке.<br>
nfqws реагирует десинхронизацией на каждый пакет из TLSClientHello, если задана опция<br>
–dpi-desync-skip-nosni=0. В противном случае десинхронизация идет на сам пакет,<br>
включающий SNI, и все последующие.</p>
<p>РЕАССЕМБЛИНГ QUIC<br>
tls-kyber может так же размазываться по 2 пакетам QUIC Initial.<br>
Пока их реассемблинг не реализован, поскольку русский DPI не реагирует на такие пакеты.<br>
Идет десинхронизация полных hello в одном пакете и частичных hello, где SNI попал в 1-й пакет.<br>
Можно только гадать как будут рубить сеанс, если вдруг блокировщики реализуют поддержку подобных hello.<br>
Если, допустим, они станут буферизировать 2 пакета, и после 2 рубить сеанс, если им не понравился SNI, то можно выплюнуть что-то между 1 и 2. Если они будут сечь долго сеанс QUIC на предмет продолжения initial, то плеваться придется между множеством пакетов. Если же и это не сработает, значит придется дурить сразу на 1 пакете, чтобы они не распознали начало QUIC протокола и не стали ничего высекать из последующих пакетов. Но это потребует буферизации уже на стороне nfqws.<br>
Так что писанина кода ожидается разная</p>
<p>Так же обновлена логика детекта tcp ретрансмиссий.<br>
По мере реконструкции TLS запроса выясняется диапазон tcp sequence numbers, покрывающий запрос.<br>
Ретрансмиссиями запроса считаются только повторные передачи из этого диапазона.<br>
При обнаружении пакета вне диапазона, счетчик ретрансмиссий немедленно завершается.<br>
Обнаружение RST или http редирект теперь жестко завязано на sequence=1 со стороны сервера.<br>
То есть реакция только на RST сразу и молча, либо передачу http redirect сразу.<br>
Все, что потом, не трогается, и реакции по auto hostlist нет</p></td><td>2023-11-15T16:49:11.651Z</td></tr><tr><td>bolvan</td><td><p>В скриптах ipset/get_reestr* сделана поддержка ipban.<br>
Забаненными IP считаются IP из реестра, которым не назначен hostname.<br>
Источник : <a href="https://raw.githubusercontent.com/zapret-info/z-i/master/dump.csv">https://raw.githubusercontent.com/zapret-info/z-i/master/dump.csv</a><br>
На деле какие-то IP забанены, какие-то нет. В dump.csv нет информации разбанена ли запись или нет.<br>
Потому лист избыточен</p></td><td>2023-11-26T11:35:57.993Z</td></tr><tr><td>bolvan</td><td><p>Добавлена возможность переопределить порты для некоторых протоколов, проведенных через основные скрипты</p>
<p>#HTTP_PORTS=80-81,85<br>
#HTTPS_PORTS=443,500-501<br>
#QUIC_PORTS=443,444</p>
<p>Может понадобится, если DPI сечет разные порты.<br>
Но вбивать сюда 1-65535 крайне не рекомендовано, поскольку весь трафик может упасть на nfqws или tpws</p></td><td>2023-12-12T18:27:07.619Z</td></tr><tr><td>bolvan</td><td><p>Переменные конфига</p>
<p>OPENWRT_WAN4<br>
OPENWRT_WAN6</p>
<p>позволяют переопределить в openwrt WAN интерфейсы для ipv4 и ipv6<br>
интерфейсы задаются как имена логических интерфейсов netifd (wan,lan), а не интерфейсов linux (eth0, eth1, br-lan)<br>
множественные интерфейсы пишутся в кавычках через пробел<br>
все по аналогии с OPENWRT_LAN<br>
полезно, когда у вас несколько ipv6 аплинков, и общая стратегия может ломать другой аплинк</p>
<p>проверка : /etc/init.d/zapret list_ifsets</p></td><td>2024-01-01T07:39:55.080Z</td></tr><tr><td>bolvan</td><td><p>Вынес отдельным скриптом install_prereq.sh установку дополнительных пакетов в ОС.<br>
Это надо для упрощения начальной процедуры развертывания, когда install_easy еще не выполнен и надо запускать blockcheck.sh.<br>
Чтобы не запускать install_easy и не прерывать его после установки пакетов, и чтобы не помнить/читать про необходимые пакеты, не копипастить большие команды по их установке. Вместо этого install_bin + install_prereq сразу готовят систему к blockcheck</p></td><td>2024-01-23T10:35:25.105Z</td></tr><tr><td>bolvan</td><td><p>Заменил в nfqws дефолтный фейк http/https с <a href="http://w3.org">w3.org</a> на <a href="http://iana.org">iana.org</a>.<br>
<a href="http://w3.org">w3.org</a> переехал на cloudflare.<br>
Особенность cloudflare такова, что он позволяет дергать все свои сайты с любых своих IP.<br>
Теперь представьте, что вы тестите в блокчеке <a href="http://rutracker.org">rutracker.org</a>, который тоже на клауде.<br>
Если TTL превысит длину пути до сервера, то сервер получит фейк.<br>
И вместо отлупа мы получаем 200 OK или 307 redirect, как будто все в порядке.<br>
А на самом деле не в порядке, эта стратегия будет ломать сайт.</p></td><td>2024-02-27T11:04:04.530Z</td></tr><tr><td>bolvan</td><td><p>Хочу обратить внимание на особенности применения zapret в текущих условиях в России.</p>
<p>Сейчас ТСПУ любят ставить у магистралов, потому приходится сдвигать TTL дальше провайдера. Может быть и 8, и даже 11.<br>
Может быть балансировка нагрузки на разные магистралы. И на одном DPI на 5-м , на другом на 11-м.<br>
Значит от раза к разу количество хопов может быть разным до сервера из-за разного маршрута.<br>
Может быть и такое, что на разные направления идет стабильно разный маршрут.<br>
Чтобы обойти какие-то сайты на одном маршруте, вы ставите 11, но на другие маршрут иной, существенно короче, и там идет облом.</p>
<p>Проблема случается, когда фейковые пакеты без фулинга доходят до сервера и воспринимаются им как реальные пакеты от клиента. На http это могут быть ошибки 400. Так реагируют сервера на необслуживаемый домен (<a href="http://iana.org">iana.org</a>, <a href="http://w3.org">w3.org</a>)<br>
На https будут ошибки другого вида, связанные с невозможностью выполнить TLS handshake.</p>
<p>Вообщем, здесь необходим дополнительный ограничитель.<br>
Самый универсальный и совместимый - md5sig. Но он работает только с linux серверами.<br>
badsum, кажется, перестал работать на многих провайдерах. Возможно, DPI стали проверять tcp checksum<br>
badseq, как показывает практика, может работать только с https, но не работать с http (особенности DPI от <a href="http://rdp.ru/%D0%A2%D0%A1%D0%9F%D0%A3">rdp.ru/ТСПУ</a>)</p>
<p>blockcheck.sh был создан не как конечный судья, выносящий вердикт “какие буковки писать сюда”.<br>
Он скорее напоминает томограф, а вы - врач, изучающий томограмму и ставящий диагноз. За вас он это не всегда сможет сделать.<br>
Потому тут надо думать и понимать что происходит, чтобы получить надежный результат, а не когда-то открывается, когда-то нет, а почему я без понятия, все вписал как сказали. Нет, это уже тоже не всегда работает</p>
<p>Самый бронебойный вариант - обход только нужных вам сайтов, которые можно вписать в фильтр по ip или hostlist, или же autohostlist.<br>
autohostlist хорош тем, что при должной настройке и минимальном обслуживании не трогает то, что трогать не нужно, тем самым минимизируя риск поломки всевозможных сбербанков.<br>
Но это не избавляет от необходимости находить надежную стратегию, иначе не будет нормально работать обход того, что вам нужно</p></td><td>2024-03-02T15:10:03.023Z</td></tr><tr><td>bolvan</td><td><ol>
<li>tpws : поддержка нового метода десинхронизации --oob. Посылка нулевого out of band байта после первой части сплита.</li>
<li>Перевод схемы nftables на обслуживание tcp соединений после NAT (POSTNAT). Это позволяет задействовать атаки, ломающие NAT. При использовании MASQUERADE они невозможны на iptables, поскольку iptables не позволяют перехватить трафик после NAT.<br>
В nftables теперь используется еще 1 бит в mark : DESYNC_MARK_POSTNAT. Так помечаются пакеты, перенаправляемые на nfqws в POSTNAT режиме. Чтобы потом можно было пакеты, генерируемые в nfqws, помечать как notrack, чтобы NAT их не ломал.<br>
POSTNAT ломает десинхронизацию UDP протоколов с первого пакета, поэтому udp идет по старинке в PRENAT режиме</li>
<li>Режим дурения datanoack. Ломающий NAT режим, требует внешнего IP адреса на системе, где производится атака. Отсылка дурящего пакета без флага ACK. Это неправильно, поэтому сервера отбрасывают, а DPI может схавать</li>
<li>Режим autottl в nfqws. На каких-то провайдерах может неплохо работать, на каких-то хуже или вообще плохо. Можно пробовать крутить параметры. Какой TTL выбрал автомат видно в nfqws --debug. Там же и видны TTL обрабатываемых пакетов. Для реализации режима требуется перенаправить как минимум первый пакет SYN,ACK</li>
</ol>
<p>Как работает autottl.<br>
<code>--dpi-desync-autottl=[&lt;delta&gt;[:&lt;min&gt;[-&lt;max&gt;]]]</code><br>
Берется входящий TTL. Если он ниже не более, чем на 31 хоп от стандартных значений 64,128,255, то соответствующее значение берется за исходный TTL входящего пакета и вычисляется длина пути как разница.<br>
При других TTL алгоритм идет в отказ.<br>
Далее от длины пути отнимается дельта, которую можно указать в параметре --dpi-desync-autottl. По умолчанию она = 1.<br>
Полученное значение берется как TTL фейк пакетов.<br>
Если оно выходит за пределы min-max, то оно нормализуется до min или до max. Если после нормализации превышена длина пути, алгоритм выдает отказ.<br>
При отказе используется фиксированное значение ttl, заданное в параметре --dpi-desync-ttl.<br>
Если у вас нет других ограничителей по fooling, лучше указать --dpi-desync-ttl=1, чтобы в случае отказа фейк пакет не дошел до сервера.<br>
Можно настроить отдельную версию параметров для ipv6.<br>
Смысл значений min-max  означает диапазон длин пути, между которыми находится DPI. Нет смысла атаковать сервера слишком близкие, которые еще до DPI. Это обычно ресурсы самого провайдера. Так же нет смысла гнать фейки слишком далеко куда-то в США, потому что там тоже нет блокирующих DPI.<br>
Значение дельты позволяет несколько сгладить небольшую разницу в длине исходящего и входящего пути. Но если сделать слишком большое значение, то можно вылезти в область DPI. Фейки перестанут доходить до DPI, и обход перестанет работать.<br>
Блокчек прогоняет тесты на несколько вариантов delta. Это тот случай, когда тестирование надо выполнять на чем большем количестве заблокированых доменов, тем лучше. На разных доменах могут работать разные дельты. Если на большинстве доменов работает какая-то дельта, то ее и нужно использовать. Если везде все по разному, то от autottl стоит отказаться.</p></td><td>2024-03-02T15:10:11.571Z</td></tr><tr><td>bolvan</td><td><p>В tpws добавлена возможность указать OOB байт. В виде символа или 0xHEX.<br>
Там же новые параметры --tamper-start и --tamper-cutoff позволяют ограничить байтовые позиции или номер блока исходящего потока, к которым применяется дурение.   start&lt;=pos&lt;cutoff<br>
cutoff - это точка отсечения, с которой больше не дурим.<br>
Позиция относится к началу текущего принятого от клиента блока.</p></td><td>2024-03-05T12:06:47.777Z</td></tr><tr><td>bolvan</td><td><p>Обнаружилось, что некоторые провайдеские NAT datanoack проходит корректно. В этом случае внешний IP адрес может быть не обязателен.<br>
megafon, beeline мобильные работают.<br>
Но linux NAT оно не проходит. За домашним роутером это бесполезно, но можно с него.</p></td><td>2024-03-05T13:56:17.987Z</td></tr><tr><td>bolvan</td><td><p>autottl на BSD системах можно завести безкровно. В смысле, не надо перенаправлять весь входящий трафик с порта (ибо connbytes отсутствует).<br>
Достаточно перенаправить 1 пакет SYN,ACK, и его легко фильтрануть правилом ipfw или PF.<br>
autohostlist в dvtws по-прежнему не рекомендован на BSD, тк требует перенаправляения более одного входящего пакета на tcp соединение, и ограничить не представляется возможным.<br>
Если ваш провайдер виснет на заблокированных ресурсах, то сработать может и без.<br>
Вариант “зависло” детектится на основе только исходящего трафика. Вариант RST или redirect детектиться не будут<br>
tpws c autohostlist работает без ограничений</p></td><td>2024-03-10T07:41:02.376Z</td></tr><tr><td>bolvan</td><td><p>Сделана частичная поддержка blockcheck в OpenBSD и MacOS. Частичная в том смысле, что tpws не поддерживается в OpenBSD, а в MacOS не поддерживается dvtws.<br>
Увы, я до сих пор не понимаю как перенаправлять трафик в OpenBSD на tpws с локальной системы (не проходной)<br>
Если брать инструкцию с route-to от TOR, то она работает, но невозможно узнать оригинальный адрес назначения у сокета через DIOCNATLOOK, так что этот варик редиректа бесполезен<br>
В MacOS это работает без проблем.</p></td><td>2024-03-11T16:06:27.129Z</td></tr><tr><td>bolvan</td><td><p>Перевел тест tpws в blockcheck на использование socks, выкинув всю муть с перенаправлением трафика через фаервол.<br>
Раньше от этого отказывался, потому что невозможно управлять версией ip (ipv4/ipv6), когда CURL работает через прокси.<br>
Пришлось вынести ресолвер отдельно. mdig ресолвит домен, далее курлу подсовывается ключ --connect-to. Он доступен с версии 7.49, следовательно совсем уж древние курлы старее мая 2016 отваливаются , равно как и старые дистрибутивы ОС в варианте “из коробки”. Если у вас такой древнющий курл, можно собрать самому или взять готовый статический бинарик.<br>
В openwrt с LEDE 17 версия curl достаточно новая.<br>
В итоге tpws теперь можно тестировать в openbsd и pfsense, а код скрипта упростился</p></td><td>2024-03-14T13:55:03.451Z</td></tr><tr><td>bolvan</td><td><p>В blockcheck добавлена проверка на обход QUIC. Для нее требуется curl с поддержкой опции --http3-only.<br>
Сейчас пока это диковинка, родной curl скорее всего не умеет<br>
Тут есть статики для разных платформ : <a href="https://github.com/stunnel/static-curl/releases" class="inline-onebox">Releases · stunnel/static-curl · GitHub</a></p></td><td>2024-03-14T21:03:42.768Z</td></tr><tr><td>bolvan</td><td><p>Десинхронизация udp на nftables тоже переведена на POSTNAT схему вместе с TCP.<br>
Этот вариант позволяет задействовать любые атаки, в том числе ломающие NAT, однако при включенном masquerade для проходного трафика может использоваться только через nftables.<br>
Например, вариант ipfrag2 работает на многих сайтах для обхода блокировки QUIC.<br>
Сеть очень плохо относится к фрагментации tcp на уровне IP. Это ненормальная ситуация, поэтому как правило такое режется.<br>
Но к фрагментации udp сеть относится относительно лояльно. Есть ситуации, когда это вообще нормально.<br>
IP фрагментация используется в IKE. В IKE уже изобрели свой метод фрагментации сообщений на уровне L7, но старые ОС об этом не знают. windows 7 отсылает фрагментированные udp, windows 10 - несколько нефрагментированных udp. Именно поэтому на некоторых VPS вам упорно не удастся подключиться к вашему strongwan с win7, и все лишь потому, что у вас слишком упертый хостер, который решил подрезать фрагментированные пакеты полностью.<br>
Фрагментация QUIC по сути тоже ненормальна, но мало кто будет лезть так глубоко и анализировать udp payload (который еще надо суметь собрать).<br>
cloudflare и <a href="http://bbc.com">bbc.com</a> обходятся через ipfrag2, на facebook режут.</p></td><td>2024-03-15T12:55:38.133Z</td></tr><tr><td>bolvan</td><td><p>Новый метод десинхронизации нулевой фазы SYNDATA.<br>
Термин нулевой фазы относится к десинхронизации на этапе TCP 3 way handshake.<br>
К ней неприменимы фильтры на основе hostlist.<br>
Этот тот случай, когда в --dpi-desync может быть 3 параметра через запятую.<br>
Можно так :  --dpi-desync=syndata,fake,split2</p>
<p>Суть в добавлении данных в пакет SYN. ОС принимают такие SYN пакеты, но данные игнорируют, а некоторые DPI их принимают. Кое-где работает на наших ТСПУ, но только для http.<br>
На https может работать, если в параметре --dpi-desync-fake-syndata передать файл, содержащий TLS client hello с незаблокированным доменом. Фактически это аналог fake, поскольку расчет на то, что DPI  принимает этот пейлоад как часть tcp stream, а сервер - нет.<br>
Некоторые российские ТСПУ/DPI на http впадают в проблемы с синхронизацией sequence numbers, что приводит только к зависанию соединения.<br>
Ломает некоторые сайты, видимо из-за собственных систем antiddos, которые плохо реагируют на аномалии</p>
<p>Поскольку ограничить хостлистом или аутохостлистом невозможно, применять с осторожностью</p>
<p>Главная цель этого режима десинхронизации - не атака на веб сайты, а атака на произвольные протоколы на конкретном сервере без применения техники split.<br>
Сейчас наблюдается такая тема на ТСПУ. Если какой-то VPN сервис или другой сервис начинает применять техники обхода блокировок, связанные с сегментацией, то ТСПУ их обнаруживает и сразу блокирует соединение. Делается это обычно на ограниченных диапазонах IP.<br>
В условиях жестких блокировок и противодействия техникам их обхода, ценна может быть каждая дырочка на свой сервер.<br>
На udp это может быть ipfrag2, а на tcp - syndata.</p></td><td>2024-03-19T10:59:54.013Z</td></tr><tr><td>bolvan</td><td><p>Оказывается, старый добрый фейк на http и https может не работать в оригинальном виде.<br>
Когда ты лезешь на http и шлешь фейк http <a href="http://iana.org">iana.org</a>, это может не сработать. Но если послать ерунду типа нулей, то может сработать. На syndata может быть наоборот. Ерунда не работает на https, а tls fake от <a href="http://iana.org">iana.org</a> - работает.</p>
<p>В связи с этим обновлен blockcheck на предмет поиска новых заковыристых стратегий</p></td><td>2024-03-19T15:08:50.722Z</td></tr><tr><td>bolvan</td><td><p>Еще немного по поводу SYNDATA.<br>
На самом деле не запрещено по стандарту слать данные прямо в SYN. Поэтому такие пакеты без проблем проходят NAT и могут учитываться DPI.<br>
Оригинальный стандарт запрещает передавать данные из SYN в сокет до полного прохождения tcp handshake. Но фактически по крайней мере linux, freebsd и windows данные в SYN игнорируют. При этом все последующие пакеты идут с сиквенсами, как будто бы SYN был пустой. То есть данные в SYN просто отбрасываются на стандартных сокетах.</p>
<p>Но есть еще более новый стандарт TCP fast open. В нем как раз отсылка данных в процессе хэндшейка - это нормально. Однако, для задействования функционала требуется особое программирование специально для поддержки fast open. Это должен уметь и серверный процесс, и клиентский.</p>
<p>Хотя некоторые веб сервера и умеют, и даже некоторые броузеры на некоторых платформах умеют, мало кто сейчас озабочен этим fast open. У меня нет статистики где и на каких ОС и на скольких сайтах он включен по умолчанию. Но как я понимаю немного где. Это уже устаревшая технология. Сейчас актуален QUIC. Он решает в том числе и проблему RTT.</p>
<p>Но если вдруг SYNDATA будет использован именно на fast open соединении, несомненно оно сломается. Поэтому соединения с признаками fast open не трогаются.</p></td><td>2024-03-19T18:21:33.608Z</td></tr><tr><td>bolvan</td><td><p>Сделал автоматическое перечитывание autohostlist другими процессами nfqws/tpws при модификации файла.<br>
Выдал, допустим, блокчек 4 разных стратегии для http/https/ipv4/ipv6.<br>
Юзер тупо вписал это в конфиг. Запущено 4 процесса.<br>
Дернул https ipv4. Отлично, занеслось в аутолист.<br>
Потом не работает. Почему ? Да потому что полезло по ipv6, а там не обновилось.</p></td><td>2024-03-23T20:02:46.862Z</td></tr><tr><td>bolvan</td><td><p>Реализован режим quick в blockcheck.<br>
Его цель - найти хоть что-то работающее максимально быстро.<br>
Изначально blockcheck создавался не как делатель волшебных пиллюль для копипасты в определенное место как на картинке. Это инструмент исследования DPI на предмет техник обхода блокировок.<br>
Но юзера некоторые ниче не понимают, они все равно копипастят, и это их единственный шанс, чтобы оно заработало. Иначе им только отказываться от продукта, потому что не могут понять что там за буковки и что с ними делать.<br>
В том числе для них может пригодиться этот режим, потому что все равно лишние буковки для них бесполезны.</p>
<p>Суть его в чем</p>
<ol>
<li>Отказ от тестов tpws. Все равно он как правило не обеспечивает должный уровень обхода.  Чтобы вернуть используйте переменную SKIP_TPWS=0</li>
<li>Поиск идет до первой рабочей стратегии</li>
<li>При нескольких попытках любой фейл приводит к концу серии попыток. Ведь все равно будет итоговый фейл</li>
</ol>
<p>По умолчанию все равно оставляю standard, чтобы основная цель скрипта оставалась неизменной</p>
<p>Из blockcheck убраны тесты ipfrag tcp, поскольку современная сеть практически не оставляет никаких шансов этому варианту.</p></td><td>2024-03-24T08:13:31.305Z</td></tr><tr><td>bolvan</td><td><p>Немного наблюдений по поводу протокола QUIC.<br>
Если кратко, то на DPI он обрабатывается криво. Алгоритмы несовершенны.<br>
Поведение DPI может зависеть от типа клиентской библиотеки.<br>
quiche может пробивать блокировку и без средств обхода.<br>
Пакеты initial от разных библиотек могут не собираться DPI, и он может не извлекать host.<br>
curl с nghttp3 может долго (1-3 сек) выполнять запрос с пробивкой по fake. Там то ли теряются, то ли искажаются пакеты от сервера, вынуждая клиент еще раз слать initial.<br>
При этом firefox может сразу и быстро открывать этот же сайт по quic, если количество пробивочных пакетов 5 и выше, и подвисать на QUIC, если меньше.<br>
Аналогично у них реализуется и блокировка wireguard udp и openvpn udp. Для пробивки нужно слать 5 фейков.<br>
DPI по-прежнему не может корректно сечь разбросанный на несколько пакетов initial. В хромах уже начали включать кибер по умолчанию, так что 50/50. Рандомизирует сигнатуру. То в первый пакет SNI попадет, то во 2-й<br>
Вообщем, сложная эта штука QUIC, и curl test может не отражать реальной специфики как поведет себя броузер</p></td><td>2024-03-25T20:31:30.663Z</td></tr><tr><td>bolvan</td><td><p>В tpws реализованы фильтры протоколов для disorder и oob.<br>
Параметр oob претерпел несовместимое изменение. Теперь наравне с disorder он берет название протокола http или tls. Если без параметра - применяется дурение ко всем протоколам. Если с параметром - только к этому протоколу.<br>
Может быть несколько --disorder или --oob. Например, можно сказать ему сделать oob для tls и http, но не делать для остальных, при условии что задано --split-any-protocol.<br>
Байт OOB перенесен в параметр --oob-data. Это нужно, потому что в tpws стали появляться стратегии, которые нужны для одних протоколов, но могут ломать другие.<br>
Для http есть отдельный split --split-http-req. Он имеет приоритет над --split-pos.<br>
Если это не http, то применяется --split-pos. Получается, можно двумя этими параметрами задать разный сплит для http и tls.<br>
Но вот disorder может сломать http на ТСПУ. В скриптах запуска можно было этот вопрос решить как с nfqws - сделать несколько параметров для http,https,http6,https6.<br>
Но tpws еще ценен наличием режима socks, а там такое сделать не выйдет, потому что в прогах нет 4 поля socks для разных вариантов. Потому принято решение идти по пути обьединения стратегий в 1 процесс.<br>
Кстати, это еще один пример, что вот так просто взять копипастнуть как на картинке может не получиться. Если вы захотите пойти путем tpws, то там только 1 поле, а стратегии выдал blockcheck две разные. И все, вы тут встряли, если вы - копипастер. А на самом деле это сделано потому, что все можно запихать в 1 стратегию, если их обьеденить, но это не для копипастеров. И, конечно, чтобы не ломать достоинство socks.<br>
tpws в текущих реалиях в России работает, но ограниченно.<br>
Как правило он может пробить http, а https только на tls 1.3.<br>
Не поддерживающие tls 1.3 заблокированные сайты пробить не получится.</p></td><td>2024-03-26T10:08:21.718Z</td></tr><tr><td>bolvan</td><td><p>Худой, но как-то работающий способ пробить TLS1.2 на tpws. Не везде, но много где. Не особо качественно. Но лучше, чем ничего.</p>
<p>–mss устанавливает опцию сокета TCP_MAXSEG. Клиент выдает это значение в tcp опциях SYN пакета.<br>
Сервер в ответ в SYN,ACK выдает свой MSS. На практике сервера обычно снижают размеры отсылаемых ими пакетов, но они все равно не вписываются в низкий MSS, указанный клиентом. Обычно чем больше указал клиент, тем больше шлет сервер. На TLS 1.2 если сервер разбил заброс так, чтобы домен из сертификата не попал в первый пакет, это может обмануть DPI, секущий ответ сервера.<br>
Схема может значительно снизить скорость и сработать не на всех сайтах.<br>
Несовместимо с фильтром по hostlist. Невозможен фильтр по версии TLS.<br>
Взамен имеется фильтр по портам --mss-pf. --mss-pf=443 применяет дурение только к https.<br>
Применяя данную опцию к сайтам TLS1.3, если броузер тоже поддерживает TLS1.3, то вы делаете только хуже.<br>
Но нет способа автоматически узнать когда надо применять, когда нет, поскольку MSS идет только в<br>
3-way handshake еще до обмена данными, а версию TLS можно узнать только по ответу сервера, который может привести к реакции DPI.<br>
Использовать только когда нет ничего лучше или для отдельных ресурсов.<br>
Работает только на linux, не работает на BSD и MacOS.</p></td><td>2024-03-27T15:01:10.754Z</td></tr><tr><td>bolvan</td><td><p>В tpws ликвидировано узкое место, связанное с ресолвером хостов.<br>
У socks proxy есть режим переадресации по IP адресу и по хосту.<br>
В curl за выбор режима отвечают параметр --socks5 или --socks5-hostname. Можно использовать  параметр --proxy socks5://… и --proxy socks5h://…    . socks5h - это как раз ресолвинг через прокси.</p>
<p>tpws основан на однопоточном обслуживании всех соединений с использованием неблокирующих сокетов и событийной модели. Тормоза в каком-то соединении не вешают остальные соединения. Но раньше ресолвинг ломал эту модель, поскольку использовался блокирующий вызов getaddrinfo. На время ресолвинга все замирало.</p>
<p>Сейчас это больше не так. Задача по ресолвингу решается в отдельных потоках, организованных в виде thread pool. Есть очередь запросов, а потоки их по мере возможности разгребают. На время ресолвинга соединение ставится на паузу, не прерывая процессинг всего остального.</p>
<p>Количество потоков ресолвера выбирается по умолчанию как  5+max_conn/50. По умолчанию max_conn=512, следовательно потоков 15. Можно переопределить в параметре --resolver-threads.</p>
<p>Да, можно было использовать какую-то отдельную библиотеку для асинхронных ресолвингов, ведь libc в общем случае такой возможности не имеет. Имеет только glibc, а musl и другие - нет. Но это зависимости, это тяжесть процесса, которую хочется избежать.</p>
<p>Помимо прямого назначения, это нововведение несет в себе и другую цель. Использование tpws в socks режиме с удаленным ресолвингом хостов дает tpws возможность узнать hostname еще до подключения к серверу. Следовательно, задействуется механизм, ограничивающий дурение по MSS через hostlist. В любом другом режиме MSS будет применяться неограниченно ко всем соединениям.</p>
<p>Как задействовать socks в броузерах.<br>
В хромиум подобных вызвать chrome так : chrome.exe --proxy-server=“socks5://localhost:1111” . Они сразу начинают задействовать режим remote_dns.<br>
В firefox можно глобально задать в about:flags параметр network.proxy.socks_remote_dns=true. А можно использовать расширение foxyproxy. Оно позволяет оперативно переключать прокси, и можно задать remote_dns для каждого прокси отдельно.</p></td><td>2024-04-02T15:55:04.810Z</td></tr><tr><td>bolvan</td><td><p>WSL 1.  Подсистема linux на win10/11 и windows server.<br>
Эмуляция вызовов ядра linux, позволяющая запускать бинарики linux.<br>
Но, естественно, в реализации есть кривизна.</p>
<p>Проверял на windows server 2022. Оказалось глючат linux pipes.<br>
Делаешь splice в pipe. Возвращает, что записал 8192 байт.<br>
Делаешь splice из pipe в сокет. B хрен вам.  EAGAIN. Как будто ничего нет в этом пайпе.<br>
Делаешь read из пайпа - тоже самое. То есть там действительно пусто.<br>
Проблема не в сокете. Если в него слать send-ом, то ошибки нет, уходит.<br>
Получается суешь в пайп, и это куда-то пропадает неизвестно куда.<br>
Логика неблокирующих сокетов приводит к зацикливанию процесса, сьедая целое ядро.</p>
<p>Сколько ни тестировал на linux, такого нет, а в винде воспроизводится на раз два.</p>
<p>Лечение - параметр --nosplice. Обход глюка винды</p></td><td>2024-04-03T19:31:13.430Z</td></tr><tr><td>bolvan</td><td><p>Исправлен целый ряд проблем, все же имевшихся в схеме postnat.<br>
Десинхронизация на первый пакет (syndata на tcp или первый пакет udp, quic, например) несет в себе проблему. Если дропать в очереди первый пакет, то ломается запись в conntrack. Его нельзя дропать.<br>
Потому было сделано особое уродование первого оригинального пакета, чтобы его пропускать в очереди.<br>
TTL использовать нельзя, поскольку linux сечет expired icmp и ресетает сокет.<br>
Использованы следующие схемы :</p>
<p>ipv4 - портим L3 чексумму ipv4 хедера. с порченой чексуммой пакет будет отброшен первым же роутером<br>
tcp - в SYN пакете сбрасываем все флаги и этим самым так же портим чексумму L4<br>
udp - в первом пакете обрезаем все данные после udp хедера, делаем длину в udp хедере нулевой (минимум 8 требуется - длина самого хедера), портим чексумму L4</p>
<p>эти меры призваны достичь результата, даже если вдруг сетевой адаптер на все делает чексум оффлоад<br>
главная цель - чтобы этот пакет никем по возможности не был воспринят как что-то значимое. ни DPI, ни сервером. но в то же время не испортилась бы запись в коннтрак</p></td><td>2024-04-08T16:51:43.037Z</td></tr><tr><td>bolvan</td><td><p>Для дурения произвольных протоколов в nfqws добавлен параметр --dpi-desync-start.</p>
<p>Он полностью аналогичен --dpi-desync-cutoff, но работает как начальный ограничитель. cutoff - конечный ограничитель.<br>
Таким образом дублируется функционал connbytes FROM:TO на уровне nfqws. Можно вырезать по номеру пакета (n), смещению позиции данных (s), а так же отсутствующий в connbytes режим - по номеру пакета данных (d). d от n отличается только тем, что считаются пакеты с непустым data payload.<br>
Этот фильтр помогает решить вопрос с отсутствующим connbytes на BSD системах или на прошивочках linux с покоцаным ядром, где нет матча connbytes.<br>
При наличии connbytes лучше это делать средствами iptables/nftables. Тогда не будет лишних редиректов user mode, скорость будет выше в разы.<br>
Если надо ограничить дурение в d режиме, игнорируя непонятное количество пустых ACK, то делаем ограничитель connbytes на максимум возможных пакетов, где нам надо что-то поймать, дальше уточняющий ограничитель в d режиме на nfqws.</p>
<p>В tpws уже реализована пара похожих параметров --tamper-start, --tamper-cutoff</p></td><td>2024-04-13T08:16:31.347Z</td></tr><tr><td>bolvan</td><td><p>В nfqws теперь обязателен параметр --qnum. Раньше был номер очереди по умолчанию 0.<br>
Сделано во избежание неверного использования, вызванного непониманием как оно работает.<br>
В iptables, кстати, NFQUEUE тоже имеет по умолчанию номер очереди 0. То есть если раньше кто-то писал iptables без queue-num, а nfqws запускал без qnum, то это работало, а теперь перестанет. Вернуть этот вариант можно через nfqws --qnum 0</p></td><td>2024-04-17T06:56:50.035Z</td></tr><tr><td>bolvan</td><td><p>В nfqws сделана система задержки пакетов.<br>
Начиная с chrome 124 по умолчанию включена пост-квантовая криптография kyber. Это раздувает TLS ClientHello до 2 пакетов, QUIC initial до 2 или 3 пакетов. Может быть и больше при низком MTU.<br>
Ранее nfqws умел реассемблировать TLS ClientHello, но проводил десинхронизацию на тот сегмент TCP, где появилось SNI и все последующие. Допустим, имеется 5 пакетов, в 3-м из которых SNI. Получается, мы имеем : tls1,tls2,fake,tls3,fake,tls4,fake,tls5. Не слишком корректное поведение. QUIC же вообще никак не реассемблировался.<br>
Теперь введена система задержки пакетов. Мы получаем tls1…tls5, но в сеть не шлем, а только запоминаем. По приходу последнего tls5 выполняется десинхронизация tls1 на основании полностью собранного запроса. Выходит так : fake,tls1,tls2,tls3,tls4,tls5. Что куда более корректно, ведь суть фейка - вынудить DPI отстать от запроса. Но как он от него отстанет в предыдущем варианте, если он сначала видит tls1. Он начинает реассемблировать вплоть до tls5. И получает испорченный блок данных где-то посередине. Такое тоже обычно срабатывает для обхода, но все же это не достигает изначальной цели fake.<br>
Для QUIC производится аналогичная процедура, только с дешифровкой каждого куска, конкатенацией расшифрованных данных до тех пор, пока из них не соберется полный ClientHello.<br>
Любая ошибка при сборке вызывает немедленную отмену реассемблирования, отсылку задержанных пакетов и отмену десинхронизации.</p></td><td>2024-04-20T18:14:04.654Z</td></tr><tr><td>bolvan</td><td><p>Реализован nfqws для windows - winws.<br>
Это фактически замена GoodbyeDPI с up-to-date функциями из nfqws.<br>
Работает практически все.<br>
Из ограничений : нет ipset, не поддерживается проходящий трафик (расшаривание соединения)<br>
Поддерживается blockcheck, но он требует установки cygwin.<br>
Сам winws установки cygwin не требует.</p>
<p>Читайте docs/windows.txt, docs/quick_start_windows.txt</p>
<p>Это дебют, так что welcome тестировать.</p></td><td>2024-04-26T18:54:32.978Z</td></tr><tr><td>bolvan</td><td><p>Создан bundle для ускоренного и упрощенного запуска blockcheck под windows. Его достаточно для полноценного развертывания winws.</p>
<aside class="onebox githubrepo" data-onebox-src="https://github.com/bol-van/zapret-win-bundle">
  <header class="source">

      <a href="https://github.com/bol-van/zapret-win-bundle" target="_blank" rel="noopener">github.com</a>
  </header>

  <article class="onebox-body">
    <div class="github-row" data-github-private-repo="false">
  <img width="690" height="344" src="zapret-whats-new-61/6a4d4e93b25d01d87d7db18939fcb5735e6b4e0e_2_690x344.png" class="thumbnail" data-dominant-color="EEF4EE">

  <h3><a href="https://github.com/bol-van/zapret-win-bundle" target="_blank" rel="noopener">GitHub - bol-van/zapret-win-bundle: zapret and blockcheck binary bundle for windows</a></h3>

    <p><span class="github-repo-description">zapret and blockcheck binary bundle for windows</span></p>
</div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Адаптирована инструкция из основного репозитория docs/quick_start_windows.txt</p></td><td>2024-04-28T09:53:19.782Z</td></tr><tr><td>bolvan</td><td><p>Сделан запуск в виде windows служб.<br>
См service_*.cmd<br>
Можно запускать и через планировщик, и как службы. Как вам больше нравится.</p></td><td>2024-04-30T12:50:38.455Z</td></tr><tr><td>bolvan</td><td><p>Устранена гонка при одновременном запуске нескольких инстансов winws.<br>
Она связана с CreateService/StartService драйвера windivert.sys<br>
Это проблема не связана напрямую с winws, а с windivert.dll</p>
<p>Устранено возможное падение при остановке сервиса</p></td><td>2024-05-01T10:59:02.633Z</td></tr><tr><td>bolvan</td><td><p>Поделюсь своим опытом изучения windows 10 arm64 под qemu-aarch64 на платформе x86.</p>
<p>Известно, что эта платформа имеет встроенный эмулятор кода x86. Бинарная трансляция. Примерно так, как это сделано в android x86 для arm - там используются libhoodini.<br>
Целью было выяснить возможно ли вообще использовать winws на базе x86_64 cygwin с неподписанным драйвером windivert для arm в режиме ядра testsigning.</p>
<p>Попытка установить win11 закончилась провалом. Все мои попытки заканчивались ошибкой установщика уже на этапе после наката install.wim на HDD. Тоже самое получалось и если install.wim накатить вручную через dism, а bcd создать вручную</p>
<p>win10 встала. Но первое, что я заметил, были совершенно невообразимые тупняки.<br>
Конечно, тормоза ожидались, но там все просто ложилось почти намертво.<br>
Как выяснилось, бинарный транслятор кода x86 под qemu-aarch64 при попытке выполнить любой бинарик x86 зацикливается с отьеданием 100% одного ядра.<br>
Неважно что это - хоть простейший cmd. Можно ждать хоть часами - ничего не меняется.<br>
Так что миссия на этом этапе провалилась. Не работает x86 код вообще.</p>
<p>А встроенного кода x86 там хватает. На удивление microsoft сильно схалявил. Целый ряд компонент windows не был перенесен на arm, а выполняется как x86 !!<br>
Начиная с onedrive, который автоматически запускается и добавляет тупняка, и заканчивая powershell, без которого , например, даже нельзя снести все эти ненужные магазинные приложения.</p>
<p>По мере чистки от левака с убиранием из автозапуска всего x86 система стала гораздо более отзывчива и даже почти юзабельна.</p>
<p>Так что пока тестировать не на чем. Требуется реальная подходящая arm железяка</p></td><td>2024-05-04T12:24:08.329Z</td></tr><tr><td>bolvan</td><td><p>Проверена работа winws на windows 11 arm64 с неподписанным драйвером windivert в режиме testsigning.<br>
Оно работает. Для быстрого наката arm64 версии сделан батник в bundle : arm64/install_arm64.cmd<br>
Все, кроме драйвера, работает в x64 эмуляции.<br>
Windows 10 arm64 не поддерживается по причине отсутствия x64 эмуляции. Поддерживается только x86.</p></td><td>2024-05-05T19:26:01.373Z</td></tr><tr><td>bolvan</td><td><p>Пару недель назад прошла такая тема, что в ОАЭ и СаудиАрабиа перестал работать GoodByeDPI.<br>
Просто начисто. Блокчек от winws так же показал безуспешность всех вариантов.<br>
Думали все очень сложно. Но оказалась банальщина. Они ищут в отдельных пакетах stateless сигнатуру SNI и смотрят там хост.<br>
Помогает сплит на SNI. Но , увы, такой функции нет в zapret. Недавно Валдик дописал это для GDPI.</p>
<p>Сейчас догоняет и zapret. Но там все несколько сложнее. Потому что поддерживаются многосегментные запросы.<br>
В tpws добавлен параметр --split-tls. Там все довольно просто, поскольку мы не имеем дело с отдельными пакетами. Все равно сколько пакетов в итоге будет.<br>
В nfqws добавлены параметры --dpi-desync-split-http-req и --dpi-desync-split-tls.<br>
И в nfqws, и в tpws для tls допустимы значения sni и sniext.  sni - значит резать после 1 символа хоста. sniext - резать между байтами 2-байтной длины SNI extension.<br>
В nfqws реализация оказалась сложнее. SNI может попасть на любой пакет в серии. Поэтому сплит-десинхронизация применяется только к тому пакету, в котором оказалась искомая позиция относительно начала всего многопакетного сообщения. Это касается как явно заданной позиции в байтах, так и автоопределения через split-tls. fake и многие другие опции идут при этом только на первый пакет серии.<br>
Это все надо, чтобы в ОАЭ без отключения кибера сразу же заработала обманка на chrome.<br>
GDPI пока что требует отключения кибер.</p>
<p>В tpws добавлена поддержка --tlsrec=sniext.<br>
tlsrec может сочетаться со split-tls. В этом случае они адаптируются , и вычисляется корректная позиция, чтобы сплит попал куда надо, учитывая дописывание дополнительного заголовка TLS record.</p>
<p>В блокчек добавлены новые тесты для описанного функционала.<br>
Сделан кэш mdig.<br>
Изначально curl запускался с именем домена. Он сам его и ресолвил. Но оказывается, что при использования прокси опции -4 и -6 не могут корректно рулить через какую версию ip пойдет запрос. А прокси нужен для tpws. На некоторых платформах прозрачный режим не работает для локального хоста, либо его сложно автоматически задействовать.<br>
Потому curl теперь гоняется с --connect-to , а хост ресолвит mdig. Ранее при каждом запросе запускался mdig. Теперь он запускается 1 раз на хост и ip версию, а результат запоминается в переменных shell. Запоминаются все ответы, и каждый раз выбирается случайный. Точно так же, как это делает стандартная система DNS</p></td><td>2024-06-18T14:58:27.058Z</td></tr><tr><td>bolvan</td><td><p>github внезапно отключил gzip compression. сломались скрипты ipset/get_reestr*.sh<br>
исправлено<br>
использовать curl --compressed нельзя, потому что на кастрированных системах curl без zlib. потому приходится эту логику реализовывать самому через шелл</p></td><td>2024-06-19T06:11:03.366Z</td></tr><tr><td>bolvan</td><td><p>Добавлена важная функция в winws.<br>
В --ssid-filter можно через запятую задать неограниченное количество имен wifi сетей (SSID). Если задана хотя бы одна сеть, то winws включается только, если подключен указанный SSID. Если SSID исчезает, winws отключается. Если SSID появляется снова, winws включается. Это нужно, чтобы можно было применять раздельное дурение к каждой отдельной wifi сети.<br>
Названия сетей должны быть написаны в том регистре, в котором их видит система. Сравнение идет с учетом регистра !<br>
При этом нет никаких проверок куда реально идет трафик. Если одновременно подключен, допустим, ethernet, и трафик идет туда, то дурение включается и выключается просто по факту наличия wifi сети, на которую трафик может и не идти. И это может сломать дурение на ethernet. Поэтому полезно так же будет добавить фильтр --wf-iface на индекс интерфейса wifi адаптера, чтобы не трогать другой трафик.</p>
<p>Зачем это надо. Представьте себе, что вы настроили winws на ноуте чайника, который ничего не понимает, никуда не полезет и ничего не будет ни запускать, ни менять. Можно настроить и сделать сервис. Окей, чайник переехал и подключился к другому wifi. Стратегия не работает и ломает сайты. Что делать ? Ограничить дурение только на те сети, в которых вы знаете какая стратегия работает. Если таких несколько, то можно создать несколько инстансов winws с разными стратегиями и разными --ssid-fllter.<br>
Таким образом чайник ничего не делает, и у него либо обходится блокировка, либо хотя бы ничего не ломается.</p></td><td>2024-06-19T16:56:34.432Z</td></tr><tr><td>bolvan</td><td><p>В blockcheck добавлены тесты открытости порта 80,443 (требуется ncat или netcat openbsd, бизибокс netcat не поддерживается !) и тесты блокировки по IP на DPI.</p>
<p>С портами все понятно. Если нет коннекта, то это сразу <em>ВСЕ</em>.<br>
Домен может ресолвиться в несколько IP. Может не быть конекта на отдельных IP, если какие-то IP зарублены полностью.</p>
<p>Бывает так же и частичный IP блок. Конект идет, но на любые запросы возвращается reset или только на определенные протоколы типа http, tls, вне зависимости от домена.<br>
Суть тестов блокировки по IP - дернуть заблокированный домен на предположительно незаблокированном ip (ip <a href="http://iana.org">iana.org</a> по умолчанию) и незаблокированный домен (<a href="http://iana.org">iana.org</a>) на заблокированном IP.<br>
Дополнительно тестируется сам неблокированный домен (<a href="http://iana.org">iana.org</a>), чтобы быть точно уверенным, что в вашей экзотической стране не зарубили даже его.<br>
Интерпретация результата целиком на пользователе и требует понимания.<br>
Логика примерно такая. Если блок идет только на DPI по домену, то блокированный домен будет давать reset, timeout или redirect на любом IP.<br>
Неблокированный домен на блокированном IP будет давать или available для http (на самом деле http code 409 или что-то такое реально вернет сервер), или ошибка при подключения по TLS сразу без задержек (что-то вроде handshake error).<br>
Эта ситуация говорит об отсутствии блока по IP.<br>
Если reset, timeout, redirect идут на неблокированном домене на блокированном IP, а блокированный домен на неблокированном IP выдает available или TLS error сразу без задержек, значит вероятно имеет место блок только по IP.<br>
Если reset, timeout, redirect идут в обоих тестах, то может иметься блок как по IP, так и по домену.<br>
Тест на блокированные IP проводится на каждый IP блокированного домена, если их несколько, а на неблокированный IP - только 1 раз на любой из IP неблокированного домена.<br>
Собственно, это то, что я часто прошу сделать руками в случае непоняток. Сейчас это автоматизировано, и по логу блокчека можно понять больше.<br>
Если действительно есть блок по IP, значит вероятно все последующие тесты будут безуспешны.<br>
Однако, бывают ситуации, когда и частичный IP блок пробивается.<br>
Например, в СаудиАрабиа оказалось, что добавление destopt хедера в ipv6 запросе пробивает блокировку. DPI не может следовать дополнительным ipv6 хедерам, не воспринимает пакет как tcp и пропускает его.<br>
В этом и суть частичного блока. Блок на IP только определенных протоколов транспортного и прикладного уровня. Если DPI не может опознать протокол, то блокировки нет.</p>
<p>Полезные переменные для blockcheck<br>
CURL_MAX_TIME=sec - сколько секунд до таймаута curl запроса. по умолчанию 2<br>
CURL_MAX_TIME_QUIC=sec - отдельно для quic. по умолчанию совпадает с предыдущим<br>
CURL_CMD=1 - показывать строку запуска curl каждый раз<br>
CURL_VERBOSE=1 - опция -v для curl. в добавок автоматически CURL_CMD=1<br>
SKIP_TPWS=1 - отказаться от TPWS тестов<br>
SKIP_TPWS=0 - не отказываться от TPWS тестов, когда по умолчанию предусмотрен отказ<br>
SKIP_PKTWS=1 - отказаться от nfqws/dvtws/winws тестов<br>
UNBLOCKED_DOM - домен, используемый для ip block тестов. по умолчанию <a href="http://iana.org">iana.org</a><br>
DOMAINS=“dom1 dom2 … domN” - какие домены тестировать. по умолчанию <a href="http://rutracker.org">rutracker.org</a></p>
<p>Переменные используются так :<br>
CURL_MAX_TIME=1 SKIP_TPWS=1 CURL_CMD=1 /opt/zapret/blockcheck.sh</p></td><td>2024-06-20T09:23:40.230Z</td></tr><tr><td>bolvan</td><td><p>ПРИМЕРЫ БЛОКИРОВКИ ТОЛЬКО ПО ДОМЕНУ БЕЗ БЛОКА ПО IP</p>
<pre><code class="lang-auto">&gt; testing iana.org on it's original ip
!!!!! AVAILABLE !!!!!
&gt; testing rutracker.org on 192.0.43.8 (iana.org)
curl: (28) Operation timed out after 1002 milliseconds with 0 bytes received
&gt; testing iana.org on 172.67.182.196 (rutracker.org)
HTTP/1.1 409 Conflict
&gt; testing iana.org on 104.21.32.39 (rutracker.org)
HTTP/1.1 409 Conflict

&gt; testing iana.org on it's original ip
!!!!! AVAILABLE !!!!!
&gt; testing rutracker.org on 192.0.43.8 (iana.org)
curl: (28) Connection timed out after 1001 milliseconds
&gt; testing iana.org on 172.67.182.196 (rutracker.org)
curl: (35) OpenSSL/3.2.1: error:0A000410:SSL routines::ssl/tls alert handshake failure
&gt; testing iana.org on 104.21.32.39 (rutracker.org)
curl: (35) OpenSSL/3.2.1: error:0A000410:SSL routines::ssl/tls alert handshake failure

&gt; testing iana.org on it's original ip
!!!!! AVAILABLE !!!!!
&gt; testing rutracker.org on 192.0.43.8 (iana.org)
HTTP/1.1 307 Temporary Redirect
Location: https://www.gblnet.net/blocked.php
&gt; testing iana.org on 172.67.182.196 (rutracker.org)
HTTP/1.1 409 Conflict
&gt; testing iana.org on 104.21.32.39 (rutracker.org)
HTTP/1.1 409 Conflict

&gt; testing iana.org on it's original ip
!!!!! AVAILABLE !!!!!
&gt; testing rutracker.org on 192.0.43.8 (iana.org)
curl: (35) Recv failure: Connection reset by peer
&gt; testing iana.org on 172.67.182.196 (rutracker.org)
curl: (35) OpenSSL/3.2.1: error:0A000410:SSL routines::ssl/tls alert handshake failure
&gt; testing iana.org on 104.21.32.39 (rutracker.org)
curl: (35) OpenSSL/3.2.1: error:0A000410:SSL routines::ssl/tls alert handshake failure
</code></pre>
<p>ПРИМЕР ПОЛНОГО IP БЛОКА ИЛИ БЛОКА TCP ПОРТА ПРИ ОТСУТСТВИИ БЛОКА ПО ДОМЕНУ</p>
<pre><code class="lang-auto">* port block tests ipv4 startmail.com:80
ncat -z -w 1 145.131.90.136 80
145.131.90.136 does not connect. netcat code 1
ncat -z -w 1 145.131.90.152 80
145.131.90.152 does not connect. netcat code 1

* curl_test_http ipv4 startmail.com
- checking without DPI bypass
curl: (28) Connection timed out after 2002 milliseconds
UNAVAILABLE code=28

- IP block tests (requires manual interpretation)
&gt; testing iana.org on it's original ip
!!!!! AVAILABLE !!!!!
&gt; testing startmail.com on 192.0.43.8 (iana.org)
HTTP/1.1 302 Found
Location: https://www.iana.org/
&gt; testing iana.org on 145.131.90.136 (startmail.com)
curl: (28) Connection timed out after 2002 milliseconds
&gt; testing iana.org on 145.131.90.152 (startmail.com)
curl: (28) Connection timed out after 2002 milliseconds
</code></pre></td><td>2024-06-22T13:24:54.771Z</td></tr><tr><td>bolvan</td><td><p>Новое дополнение к split и disorder. Опция --dpi-desync-split-seqovl.<br>
Это достаточно сложная для понимания концепция, если не представляешь себе хорошо как работает tcp протокол.<br>
Если сказать по-простому, то это замешивание фейковых данных и реальных в разделяемые сегменты tcp. Замешивание идет через игру с sequence numbers таким образом, чтобы сервер воспринял лишь оригинал, а DPI было очень сложно разобраться где оригинал, а где мусор.<br>
Этот вариант может не требовать отдельных фейк пакетов, а следовательно TTL и fooling.</p>
<p>На ТСПУ игра с sequence обычно вызывает зависание http, но работает на https.</p>
<p>Полное описание из readme.</p>
<p>seqovl добавляет в начало первой отсылаемой части оригинального пакета (1 часть для split и 2 часть для disorder) seqovl байт со смещенным в минус sequence number на величину seqovl.<br>
В случае split2 расчет идет на то, что предыдущий отсыл, если он был, уже попал в сокет серверного приложения, поэтому новая пришедшая часть лишь частично находится в пределах текущего окна (in-window). Спереди фейковая часть отбрасывается, а оставшаяся часть содержит оригинал и начинается с начала window, поэтому попадает в сокет. Серверное приложение получает все, что реально отсылает клиент, отбрасывая фейковую out-of-window часть. Но DPI не может этого понять, поэтому у него происходит sequence десинхронизация.</p>
<p>Для disorder2 overlap идет на 2-ю часть пакета. Обязательно, чтобы seqovl был меньше split_pos, иначе все отосланное будет передано в сокет сразу же, включая фейк, ломая протокол прикладного уровня. При соблюдении этого условия 2-я часть пакета является полностью in-window, поэтому серверная ОС принимает ее целиком, включая фейк. Но поскольку начальная часть данных из 1 пакета еще не принята, то фейк и реальные данные остаются в памяти ядра, не отправляясь в серверное приложение. Как только приходит 1-я часть пакета, она переписывает фейковую часть в памяти ядра. Ядро получает данные из 1 и 2 части, поэтому далее идет отправка в сокет приложения. Таково поведение всех unix ОС - оставлять последние принятые данные.<br>
Для windows серверов может быть наоборот, поэтому не факт, что такой вариант будет на них работать. Метод позволяет обойтись без fooling и TTL. Фейки перемешаны с реальным данными.<br>
split/disorder вместо split2/disorder2 по-прежнему добавляют дополнительные отдельные фейки.</p>
<p>Как показывает практика, на https оно может не работать на TLS1.2, поскольку сечется ответ сервера с сертификатом. Только --wssize 1:6 позволяет это обойти.</p></td><td>2024-06-24T14:05:23.395Z</td></tr><tr><td>bolvan</td><td><p>Исправлен существенный косяк blockcheck.<br>
На curl, собранном с использованием версии openssl с quic (quictls), библиотека не определялась как openssl и не включался параметр tls-max.<br>
Поэтому все запросы шли реально на tls1.3, что давало искаженную картину.</p>
<p>Добавлен специфический seqovl тест на подсовывание полного ClientHello от <a href="http://iana.org">iana.org</a>. Аналог <strong>fake,split2</strong> , только в одном флаконе.<br>
ТСПУ отстает от такого TLS 1.2 запроса, не проверяя ответ сервера, и поэтому не нужен --wssize , снижающий скорость</p>
<pre><code class="lang-auto">- checking nfqws --dpi-desync=split2 --dpi-desync-split-seqovl=1 --dpi-desync-split-pos=2
curl: (35) Recv failure: Connection reset by peer
UNAVAILABLE code=35
- checking nfqws --dpi-desync=split2 --dpi-desync-split-seqovl=336 --dpi-desync-split-seqovl-pattern=/opt/zapret/files/fake/tls_clienthello_iana_org.bin
!!!!! AVAILABLE !!!!!
</code></pre>
<p>336 потому, что остаток до 517 байт заполнен нулями. ТСПУ их игнорирует.  У нас же пойдет начало реального запроса вместо нулей. По умолчанию 2 байта.</p>
<p>В zapret-win-bundle еще косяк. Не положил files/fake. Из-за этого все тесты, их использующие, не работали.<br>
/bin/sh был копией /bin/bash. Заменено на dash.  dash в несколько раз быстрее bash. blockcheck стал бегать повеселее</p></td><td>2024-06-25T06:56:08.898Z</td></tr><tr><td>bolvan</td><td><p>В winws в добавок к ssid-filter сделан NLM filter.</p>
<pre><code class="lang-auto">--nlm-filter=net1[,net2,net3,...] ; включать winws только когда подключена любая из указанных сетей NLM
--nlm-list[=all] ; вывести список сетей NLM. по умолчанию только подключенных, all - всех.
</code></pre>
<p>–nlm-filter аналогичен --ssid-filter, но работает с именами или GUIDами сетей Network List Manager (NLM). Это те сети, которые вы видите в панели управления в разделе “Центр управления сетями и общим доступом”. Под сетью подразумевается не конкретный адаптер, а именно сетевое окружение конкретного подключения. Обычно проверяется mac адрес шлюза. К сети можно подключиться через любой адаптер, и она останется той же самой. Если подключиться, допустим, к разными роутерам по кабелю, то будут разные сети. А если к одному роутеру через 2 разных сетевых карточки на том же компе - будет одна сеть. NLM абстрагирует типы сетевых адаптеров. Он работает как с wifi, так и с ethernet и любыми другими. Поэтому это более универсальный метод, чем ssid фильтр.</p></td><td>2024-07-12T12:24:55.444Z</td></tr><tr><td>bolvan</td><td><p>В режим autohostlist внесен дополнительный механизм избегания ложных срабатываний.<br>
Раньше чтобы добавить в лист домен нужно было, чтобы он фейлился столько-то раз на протяжении такого-то времени. При этом могло быть так. Плохо,  хорошо, плохо, хорошо, хорошо, плохо. Это вызывало попадание в лист. Сейчас “хорошо” сразу же сбрасывает счетчик “плохо”. Цель - обнаружить постоянное “плохо”. Если оно через раз, значит либо это проблемы самого сайта (перегруз, например), либо ваша стратегия обхода неустойчива.<br>
Работает и в nfqws, и в tpws.<br>
Под “хорошо” понимается прием любых данных от сервера, не содержащих http redirect на другой домен (заглушку), либо отсыл любого пакета с sequence number, выходящим за пределы TLS ClientHello (то есть процесс пошел дальше, значит клиент принял что-то от сервера, и это уже не затык на DPI)</p></td><td>2024-07-16T11:53:35.840Z</td></tr><tr><td>bolvan</td><td><p>В blockcheck сделана корректная зачистка при обрыве терминала. Например, отвалился ssh.</p>
<p>Из git удалены все изменяемые файлы. Это config, init.d/{macos,sysv,openwrt}/custom, ipset/zapret-hosts-user*.txt<br>
Они переименованы с расширением .default.<br>
Инсталятор если увидит отсутствие этих файлов скопирует их с .default<br>
blockcheck скопирует только config<br>
zapret-hosts-user-ipban.txt и zapret-hosts-user.txt удалены. они заполняются кодом в инсталяторе.</p>
<p>Это сделано чтобы можно было не парясь накатывать файлы поверх имеющейся инсталяхи или делать git pull не парясь о нестыковках.</p></td><td>2024-07-30T14:33:31.585Z</td></tr><tr><td>bolvan</td><td><p>Распространенная проблема, связанная с ютубе,</p>
<p>Чел сканирует блокчеком, находит стратегию с TTL. Она обходит большинство заблокированных ресурсов.<br>
Чел добавляет <a href="http://googlevideo.com">googlevideo.com</a>. Он ломается.<br>
Догадайтесь почему. &lt;вступает в силу необходимость понимать что пишешь, а не копировать&gt;</p>
<details>
<summary>
Спойлер</summary>
<p>Все дело в том, что GGC ставятся поближе к провайдеру и часто имеют длину пути ниже указанного в стратегии. Фейки доходят до сервера и ломают сеанс.<br>
Решение - добавить ограничитель. Наиболее совместимый - --dpi-desync-fooling=md5sig<br>
Если у вас работает --dpi-desync-fooling=datanoack, то можно избавиться от TTL полностью.<br>
Он вероятно не будет работать через домашний роутер, но может работать с него.</p>
</details>
<p>другая возможная причина тупняка - не настроен обход quic<br>
да, quic они тоже замедляют. работает --dpi-desync=fake.<br>
его нельзя сочетать с ttl.<br>
возможно, какие-то ТСПУ еще не научились разбирать kyber quic, потому на них дефолтный хроме может обходить замедление сам по себе. потому в сети ходит противоречивая инфа то включать quic, то выключать. GDPI quic не поддерживает.<br>
так же известно, что у ТСПУ исторически были проблемы с пакетами quic от разных библиотек разных версий. и на протяжении истории это менялось. они что-то доделывали.<br>
с zapret-ом , наверно, лучше все-же сделать fake на quic. хуже не станет. и kyber тоже поддерживается</p></td><td>2024-07-31T07:11:47.541Z</td></tr><tr><td>bolvan</td><td><p>Еще немного наблюдений по поводу обхода замедления ютубе.</p>
<p>split2 работает, но исключительно потому, что позиция по умолчанию - 2.<br>
Работает простой сплит на позиции 1 и 2. 3 байта в начале - это маркер TLS. Если DPI видит TLS оно начинает реассемблировать пакеты до получения full tls client hello. Внедрение кибера не оставила вариантов цензорам. Приходится реассемблить.<br>
Поэтому простые сплиты на позиции более 2 не срабатывают.<br>
Но работает практически любая мишура. fake, disorder2, oob, split.</p></td><td>2024-08-01T05:59:25.082Z</td></tr><tr><td>bolvan</td><td><p>Написал краткий FAQ по поводу обхода youtube средствами zapret :</p><aside class="onebox allowlistedgeneric" data-onebox-src="https://github.com/bol-van/zapret/discussions/200">
  <header class="source">
      <img src="https://ntc.party/uploads/default/original/2X/b/bad3e5f9ad67c1ddf145107ce7032ac1d7b22563.svg" class="site-icon" data-dominant-color="" width="32" height="32">

      <a href="https://github.com/bol-van/zapret/discussions/200" target="_blank" rel="noopener">GitHub</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/344;"><img src="zapret-whats-new-61/322f17304088f52391a9756b2929dfebda018f53_2_690x345.png" class="thumbnail" data-dominant-color="F0F3F1" width="690" height="345"></div>

<h3><a href="https://github.com/bol-van/zapret/discussions/200" target="_blank" rel="noopener">Обход замедления youtube в России · bol-van/zapret · Discussion #200</a></h3>

  <p>РКН замедляет некоторые домены youtube как на https, так и на quic. Проверка на youtube android app показывает замедление или блокировку следующих доменов (включая поддомены, если таковые есть) : g...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>
</td><td>2024-08-01T08:57:29.481Z</td></tr><tr><td>bolvan</td><td><p>Оказывается, не так все просто с windows 7 и готовым winws из комплекта zapret.</p>
<p>Требования к подписи драйверов windows изменились в 2021 году. Официальные бесплатные обновления windows 7 закончились в 2020. После этого несколько лет продолжали идти платные обновления по программе ESU. Именно в этих ESU обновлениях находится обновление ядра windows 7, позволяющиее загрузить драйвер windivert 2.2.2-A, который идет в поставке zapret.<br>
Поэтому варианты следующие :</p>
<ol>
<li>
<p>Взять windivert64.sys и windivert.dll версии 2.2.0-C или 2.2.0-D отсюда : <a href="https://reqrypt.org/download" class="inline-onebox">Index of /download/</a><br>
и заменить эти 2 файла. В zapret-win-bundle есть отдельных 2 места, где находится winws : zapret-winws и blockcheck/zapret/nfq. Надо менять в обоих местах. Этот вариант проверен и должен работать. Тем не менее патч 10 летней давности, который включает SHA256 сигнатуры, все еще необходим.</p>
</li>
<li>
<p>Взломать ESU : <a href="https://hackandpwn.com/windows-7-esu-patching/" class="inline-onebox">Windows 7 ESU Patching · HackAndPwn</a><br>
<a href="http://www.bifido.net/tweaks-and-scripts/8-extended-security-updates-installer.html" class="inline-onebox">Скрипт для установки и интеграции платных обновлений (ESU)</a><br>
и обновить систему</p>
</li>
<li>
<p>Использовать UpdatePack7R2 от simplix : <a href="https://blog.simplix.info">https://blog.simplix.info</a><br>
Но с этим паком есть проблема. Автор из Украины, он очень обиделся на русских. Если в панели управления стоит регион RU или BY, появляется неприятный диалог. Чтобы эту проблему обойти, можно поставить временно любой другой регион, потом вернуть. Так же нет никаких гарантий, что автор не насовал туда какой-то зловредный код. Использовать на свой страх и риск.<br>
Более безопасный вариант - скачать последнюю нормальную версию : 22.2.10<br>
<a href="https://nnmclub.to/forum/viewtopic.php?t=1530323" class="inline-onebox">Набор обновлений UpdatePack7R2 для Windows 7 SP1 и Server 2008 R2 SP1 22.2.10 [Multi/Ru] :: NNM-Club</a><br>
Ее достаточно, чтобы windivert 2.2.2-A заработал на windows 7.</p>
</li>
</ol></td><td>2024-08-02T17:44:08.613Z</td></tr><tr><td>bolvan</td><td><p>Оказалось, что утечки памяти ядра и падения кинетика при использовании nfqws к zapret отношения не имеют. Кинетик использует старое ядро с багом, который давно пофиксили, но в кинетике непатченная версия. Разрабы собираются выкатывать патч в новых прошивках</p></td><td>2024-08-22T14:18:08.259Z</td></tr><tr><td>bolvan</td><td><p>Очередное обновление.</p>
<p>Почистили немного C код по результатам статического и динамического анализа</p>
<p>В dvtws больше не используются raw сокеты для отсылки ipv4 пакетов. Вместо них используется divert. Поэтому “not sockarg” в правилах ipfw больше не нужно. Так же это призвано наладить совместимость с древними версиями BSD, где sockarg еще нет ( я не проверял, но кто-то писал issue, у него были проблемы из-за этого в freebsd 7.4, вышедшей в 2011 году ).<br>
Но главной целью этого изменения было попробовать завести divert через divert-to в pf. Увы, попытка провалилась, идет зацикливание. Механизм предотвращения зацикливания divert в pf сломан в FreeBSD и как следствие в pf/opn sense включая версию ядра 14-RELEASE.<br>
Кто-то выкатывал патч для ядра BSD, но видимо его еще не накатили в релизе.<br>
А ipfw иногда глючит с pf вместе. Потому запуск dvtws на pf/opn sense может иметь неожиданные последствия.</p>
<p>В nfqws и tpws исправлен детект TLS ClientHello на очень старых криптолибах, которые шлют SSL 3.0 версию в TLS record layer , а в handshake - TLS 1.2. Старые телики самсунг, например.</p>
<p>nfqws и tpws теперь умеют логить --debug в файл и syslog.<br>
syslog очень удобен на openwrt, потому что там используется logd с циклическим буфером в памяти. Читать через logread.<br>
–debug параметр можно вносить в опции NFQWS или TPWS в конфиге, но лучше в самом начале, иначе не поймаются ошибки при анализе командной строки.</p>
<p>В tpws добавлена опция --connect-bind-addr. В ней можно задать ipv4 или ipv6 адрес, с которого будут выполняться исходящие подключения. Для указания и v4, и v6 можно опцию повторить.<br>
Поддерживается и нотация fe80:xxxx:xxxx:…%interface_name для v6 link locals.<br>
Однако , это не отменяет правил маршрутизации. Пакет пойдет на тот интерфейс, куда его направит система маршрутизации ip rule/ip route и прочее. Исключение - разве что link local. Там пойдет на тот интерфейс, который будет после %. По другому и нельзя применять link locals.<br>
Так что не ждите чуда, чтобы направить коннект на какой-то специфический интерфейс.<br>
На openwrt используются правила маршрутизации ipv6 с from, поэтому там это может сработать.<br>
И не стоит удивляться, если вдруг вы указали адрес VPN, а в tcpdump оно идет на обычный инет с адресом обычного инета. Если default route на обычный инет более приоритетен, то ваш IP адрес VPN превращается через MASQUERADE в адрес обычного инета.<br>
Вообщем, эта опция не есть панацея для выбора исходящего интерфейса сама по себе.</p>
<p>В tpws в режиме --debug добавлено логирование с какого enpoint-а (ip:source_port) идет подключение к удаленному ресурсу. Это может быть полезно для соотнесения лога tpws с дампом wireshark или tcpdump.</p></td><td>2024-08-24T07:20:55.541Z</td></tr><tr><td>bolvan</td><td><p>Немного переписана логика закрытия соединений в tpws.</p>
<p>Обнаружена такая проблема, что если клиент инициирует shutdown соединения, и нет неотосланных данных, tpws сразу же бросает оба конекта, не давая серверу дослать оставшиеся данные. Получается, клиент ждет последнего ответа, а ему приходит FIN, как будто сервер ничего не прислал.<br>
Логика этой ситуации переписана с использованием вызова shutdown().<br>
Теперь соединение через tpws должно корректно перекачивать все байтики до конца.<br>
Так же сделан детект обрыва соединения через RST и воспроизведение RST на другом конце (leg).<br>
Это секут броузеры. Если им приходит RST, они пытаются что-то делать еще, а если FIN, то могут посчитать, что сервер прислал пустышку (ошибка протокола).</p>
<p>В результате этих изменений могут появляться надолго подвисшие конекты через tpws, если один из концов принял соединение и повис, не отвечая на FIN.<br>
Эта ситуация разрешается через FIN_WAIT timeout. Через какое-то время (до нескольких минут на BSD) соединения закроются.</p></td><td>2024-08-26T12:25:57.597Z</td></tr><tr><td>bolvan</td><td><p>Для смягчения вышеописанного недостатка с FIN_TIMEOUT на linux и macos сделал поддержку tcp user timeout. FreeBSD и OpenBSD не поддерживают.</p>
<p>–local-tcp-user-timeout и --remote-tcp-user-timeout устанавливают значение таймаута в секундах<br>
для соединений клиент-прокси и прокси-сервер. Этот таймаут соответствует опции сокета linux<br>
TCP_USER_TIMEOUT. Под таймаутом подразумевается время, в течение которого буферизированные данные не переданы или на переданные данные не получено подтверждение (ACK) от другой стороны.<br>
Этот таймаут никак не касается времени отсутствия какой-либо передачи через сокет лишь потому,<br>
что данных для передачи нет. Полезно для сокращения время закрытия подвисших соединений.<br>
Поддерживается только на Linux и MacOS.</p>
<p>По умолчанию - 10 сек для local leg, 20 сек - для remote leg.<br>
Если сделать 0, то setsockopt не будет выполнен, оставляя системное значение.</p></td><td>2024-08-27T15:38:21.035Z</td></tr><tr><td>bolvan</td><td><p>Проверил на эмуляторе android youtube app от google.<br>
Тупит, не загружается.<br>
Тупит на <a href="http://youtubei.googleapis.com">youtubei.googleapis.com</a> и *.googlevideo.com<br>
Остальное превьюшки - и еще что-то.<br>
<a href="http://yt3.ggpht.com">yt3.ggpht.com</a> у меня вообще был заблокирован - зависание или RST</p>
<pre><code class="lang-auto">googlevideo.com
youtubei.googleapis.com
i.ytimg.com
yt3.ggpht.com
</code></pre>
<p>После задуривания всех этих доменов в режиме как на обход блокировок приложение работает нормально.</p></td><td>2024-08-29T07:12:11.097Z</td></tr><tr><td>bolvan</td><td><p>Провы по глупости стали дурить DPI, чтобы создать сиюминутное конкурентное преимущество.<br>
В ответ в РКН включили особый режим против дурения на некоторых ggc.<br>
Перестали работать фейки. Но им пришлось оставить разрешенными SNI от гуглодоменов.<br>
Поэтому дописываем в стратегию <code>--dpi-desync-fake-tls=/opt/zapret/files/fake/tls_clienthello_www_google_com.bin</code> , и пока этого достаточно для дурения и блокировок, и ютуба.</p>
<p>Тем не менее чисто профилактически в nfqws заменен дефольный ClientHello на версию от firefox 128 без kyber. Сделана рандомизация SNI в формате <code>[a-z][a-z0-9]{5}\.(com|org|net|edu|gov|biz)</code><br>
Так же рандомизируются поля random и session id.<br>
Рандомизация применяется только к дефолтному фейку. Если указать внешний файл для фейка - он будет как есть. Рандомизация выполняется 1 раз при старте nfqws.</p>
<p>Пофиксены 2 проблемы на архитектуре mips64 : сломаный seccomp filter и threaded resolver в tpws</p>
<p>В mdig пофиксено отображение статистики на 32-битных архитектурах с 64-битным time_t</p></td><td>2024-09-14T19:26:01.906Z</td></tr><tr><td>bolvan</td><td><p>МНОЖЕСТВЕННЫЕ СТРАТЕГИИ<br>
nfqws способен по-разному реагировать на различные запросы и применять разные стратегии дурения. Это реализовано посредством поддержки множества профилей дурения. Профили разделяются в командной строке параметром --new. Первый профиль создается автоматически.<br>
Для него не нужно --new. Каждый профиль имеет фильтр. По умолчанию он пуст, то есть профиль удовлетворяет любым условиям. Фильтр может содержать жесткие параметры : версия ip протокола или порты tcp/udp. Они всегда однозначно идентифицируются даже на нулевой фазе десинхронизации, когда еще хост неизвестен. В качестве фильтра могут выступать и хост-листы. Они могут сочетаться с жесткими параметрами. При поступлении запроса идет проверка профилей в порядке от первого до последнего до достижения первого совпадения с фильтром. Жесткие параметры фильтра сверяются первыми. При несовпадении идет сразу же переход к следующему профилю. Если какой-то профиль удовлетворяет жесткому фильтру и содержит авто-хостлист, он выбирается сразу. Если профиль удовлетворяет жесткому фильтру, для него задан хостлист, и у нас еще нет имени хоста, идет переход к следующему профилю. В противном случае идет проверка по хостлистам этого профиля. Если имя хоста удовлетворяет листам, выбирается этот профиль. Иначе идет переход к следующему.<br>
Может так случиться, что до получения имени хоста соединение идет по одному профилю, а при получении хоста профиль меняется на лету. Поэтому если у вас есть параметры дурения нулевой фазы, тщательно продумывайте что может произойти при переключении стратегии. Смотрите debug log, чтобы лучше понять что делает nfqws.<br>
Нумерация профилей идет с 1 до N. Последним в цепочке создается пустой профиль с номером 0.<br>
Он используется, когда никакие условия фильтров не совпали.</p>
<p>ВАЖНО : множественные стратегии создавались только для случаев, когда невозможно обьединить имеющиеся стратегии для разных ресурсов. Копирование стратегий из blockcheck для разных сайтов во множество профилей без понимания как они работают приведет к нагромождению параметров, которые все равно не покроют все возможные заблокированные ресурсы. Вы только увязните в этой каше.</p>
<p>Мульти-профиль для tpws будет позже.<br>
Рефакторинг был серьезный, поэтому необходимо тестирование !</p></td><td>2024-09-17T17:09:56.282Z</td></tr><tr><td>bolvan</td><td><p>Несколько практических замечаний по поводу мульти-стратегий.<br>
Если используются скрипты zapret, то в опции NFQWS сначала пишите специальные стратегии для особых доменов. После них пишите --new и дальше то, что было там раньше.<br>
Все свои “фишки” типа стандартных листов / автолиста скрипты zapret добавляют в конец - к последнему профилю десинхронизации.</p>
<p><strong>НЕСОВМЕСТИМОЕ ИЗМЕНЕНИЕ.</strong><br>
<strong>В новой концепции профилей методы нулевой фазы десинхронизации несовместимы с хост-листами и больше не применяются !</strong><br>
Ранее они применялись , игнорируя хостлист.<br>
Если у вас были стратегии с syndata или wssize и включен режим hostlist, то syndata и wssize не будут применены. Остальные методы 1 и 2 фазы будут применены как обычно.<br>
Если включен режим autohostlist, то syndata и wssize будут применяться, поскольку профиль с autohostlist приоритетен.</p>
<p>Пример :<br>
<code>NFQWS_OPT_DESYNC="--hostlist=/opt/zapret_lists/list-youtube.txt --dpi-desync=split2 --new --dpi-desync=fake,split --dpi-desync-ttl=0 --dpi-desync-fooling=datanoack" NFQWS_OPT_DESYNC_HTTPS6="--hostlist=/opt/zapret_lists/list-youtube.txt --dpi-desync=fake,split2 --dpi-desync-ttl=5 --dpi-desync-fooling=datanoack --dpi-desync-fake-tls=/opt/zapret/files/fake/tls_clienthello_www_google_com.bin --new --dpi-desync=fake,split2 --dpi-desync-ttl=5 --dpi-desync-fooling=datanoack"</code></p>
<p>Вот так изменилось содержимое preset_russia.cmd для winws :<br>
<code>start "zapret: http,https,quic" /min "%~dp0winws.exe" --wf-tcp=80,443 --wf-udp=443 --filter-udp=443 --dpi-desync=fake --dpi-desync-repeats=11 --new --filter-tcp=80 --dpi-desync=fake,split2 --dpi-desync-autottl=2 --dpi-desync-fooling=md5sig --new --filter-tcp=443 --hostlist="%~dp0list-youtube.txt" --dpi-desync=fake,split2 --dpi-desync-autottl=2 --dpi-desync-fooling=md5sig --dpi-desync-fake-tls="%~dp0tls_clienthello_www_google_com.bin" --new --dpi-desync=fake,disorder2 --dpi-desync-autottl=2 --dpi-desync-fooling=md5sig</code></p>
<p>windivert filter : это то, что захватывает ядро и передает процессу winws. Аналог ip/nf tables.<br>
1 профиль : udp 443 - для quic<br>
2 профиль : tcp port 80 - для http<br>
3 профиль : tcp port 443 с листом list-youtube.txt .  https для ютуба<br>
4 профиль : все остальные https</p>
<p>Теперь продумайте логику как это работает.<br>
Мы обрабатываем только порты 80 и 443 для tcp и порт 443 для udp.<br>
Иного к нам не спустит windivert.</p>
<p>Если у нас порт udp 443, то применять fake.<br>
Тут жесткая фиксация, udp на другой профиль попасть не может.</p>
<p>Если tcp port 80, то тут тоже все однозначно. Другой профиль невозможен</p>
<p>Если tcp port 443, то начало соединения на нулевой фазе идет по профилю 4.<br>
Но т.к. нет методов нулевой фазы (wssize, syndata и тому подобное), то никаких действий не будет.<br>
Как только получаем хостнейм из SNI, идет проверка заново по всем профилям.<br>
1,2 профили отбрасываются , поскольку не удовлетворяют жесткому фильтру.<br>
На 3 профиле идет проверка hostname по листу list-youtube.txt<br>
Если хост в этом листе, выбирается профиль 3. Здесь происходит смена профиля на лету.<br>
Иначе профиль остается как был - 4.</p>
<p>Посмотрим на preset_russia_autohostlist.cmd<br>
<code>start "zapret: http,https,quic" /min "%~dp0winws.exe" --wf-tcp=80,443 --wf-udp=443 --filter-udp=443 --dpi-desync=fake --dpi-desync-repeats=11 --new --filter-tcp=80 --dpi-desync=fake,split2 --dpi-desync-autottl=2 --dpi-desync-fooling=md5sig --hostlist-auto="%~dp0autohostlist.txt" --new --filter-tcp=443 --hostlist="%~dp0list-youtube.txt" --dpi-desync=fake,split2 --dpi-desync-autottl=2 --dpi-desync-fooling=md5sig --dpi-desync-fake-tls="%~dp0tls_clienthello_www_google_com.bin" --new --dpi-desync=fake,disorder2 --dpi-desync-autottl=2 --dpi-desync-fooling=md5sig --hostlist-auto="%~dp0autohostlist.txt"</code></p>
<p>Разница только в наличии параметра --hostlist-auto. Причем он подтянут сразу к 2 профилям : 2 и 4.<br>
Можно делать разные автолисты для жестких профилей, но можно использовать и 1 файл.<br>
Почему я написал 2 раза автолист ? Потому что сперва идет проверка жесткого фильтра. Если у нас порт 80, до профиля 4 мы не доберемся, и автолист не будет задействован.<br>
Автолист всегда надо писать на последнем профиле, к которому может дойти проверка на жестком фильтре. Если таких путей несколько, и вы хотите автолист на всех, то и писать надо во все места.<br>
Но если бы вы написали автолист на профиле 3, это была бы большая глупость.<br>
До профиля 4 дело бы вообще не дошло, и все бы обслуживалось по профилю 3.</p>
<p>Теперь подумайте куда надо было бы написать wssize и syndata для https, если бы они были в стратегии. Правильный ответ - в профиль 4. Даже для ютуба, который идет по профилю 3. И они будут применятся ко всем сайтам, потому что не фильтруются по хостлисту.</p>
<p>А что будет со старыми конфигами ? Ничего не будет. Они так же будут работать по единственному профилю. За исключением упомянутого выше несовместимого изменения. Если в стратегии были syndata или wssize, и был задан режим hostlist, стратегия полностью или частично перестанет работать. Например, может пропасть ютубе на телике, но остаться на компе (тк TLS 1.2 перестал обходиться). В последнем случае меняйте стратегию или отказывайтесь от hostlist. Чтобы работало как раньше, надо было бы дописать еще один профиль c wssize/syndata, но уже после дополнительных параметров с листами, которые сформируют скрипты zapret. Пока это не реализовано в основном функционале, хотя может быть сделано через custom script.</p>
<p>Почему нельзя было бы сделать как раньше сразу ? Представьте такой вариант<br>
<code>--hostlist a --wssize 1:6 --new --hostlist b --wssize 2:5</code><br>
хостнейм мы не знаем. что выбирать ?</p></td><td>2024-09-17T17:15:26.214Z</td></tr><tr><td>bolvan</td><td><p>Решение проблемы с несовместимостью <code>wssize/syndata</code> с <code>MODE_FILTER=hostlist.</code></p>
<p>Добавлены переменные конфига</p>
<pre><code class="lang-auto">#NFQWS_OPT_DESYNC_SUFFIX="--dpi-desync=syndata"
#NFQWS_OPT_DESYNC_HTTP_SUFFIX="--dpi-desync=syndata"
#NFQWS_OPT_DESYNC_HTTPS_SUFFIX="--wssize 1:6"
#NFQWS_OPT_DESYNC_HTTP6_SUFFIX="--dpi-desync=syndata"
#NFQWS_OPT_DESYNC_HTTPS6_SUFFIX="--wssize 1:6"
</code></pre>
<p>Значения по умолчанию копируются в незаполненные специализированные версии аналогичным образом, как и в основных параметрах.<br>
К параметрам nfqws добавляется <code>--new &lt;suffix_strategy&gt;</code>.<br>
Итоговые параметры nfqws могут быть такими :  <code>&lt;main_strategy&gt; --hostlist=ipset/zapret-hosts-user.txt --new &lt;suffix_strategy&gt;</code></p>
<p>Реальный пример.<br>
У вас раньше стояло так :</p>
<pre><code class="lang-auto">MODE_FILTER=hostlist
NFQWS_OPT_DESYNC_HTTPS="--dpi-desync=fake --dpi-desync-fooling=datanoack --wssize 1:6"
</code></pre>
<p>Это перестало работать.<br>
Надо сделать так :</p>
<pre><code class="lang-auto">MODE_FILTER=hostlist
NFQWS_OPT_DESYNC_HTTPS="--dpi-desync=fake --dpi-desync-fooling=datanoack"
NFQWS_OPT_DESYNC_HTTPS_SUFFIX="--wssize 1:6"
</code></pre>
<p>Здесь вы явно указываете, что wssize применяется всегда, вне зависимости от хостлист фильтра.<br>
Так было и раньше, но теперь старый вариант указания параметров не работает.<br>
Менять запись нужно только если MODE_FILTER=hostlist. Если там что-то еще - не нужно. Наоборот, если вы уберете wssize из основных параметров и напишите в суффикс без MODE_FILTER=hostlist, то wssize опять перестанет работать, поскольку дело не дойдет до suffix профиля.</p>
<p>Чтобы wssize работал всегда вне зависимости от MODE_FILTER, можно написать так :</p>
<pre><code class="lang-auto">NFQWS_OPT_DESYNC_HTTPS="--dpi-desync=fake --dpi-desync-fooling=datanoack --wssize 1:6"
NFQWS_OPT_DESYNC_HTTPS_SUFFIX="--wssize 1:6"
</code></pre></td><td>2024-09-18T16:39:16.538Z</td></tr><tr><td>bolvan</td><td><p>tpws тоже переделан на множественные стратегии</p>
<p>Работают аналогично nfqws, кроме некоторых моментов.<br>
Нет параметра --filter-udp, поскольку tpws udp не поддерживает.<br>
Методы нулевой фазы (–mss) могут работать по хостлисту в одном единственном случае :<br>
если используется режим socks и удаленный ресолвинг хостов через прокси.<br>
То есть работоспособность вашей настройки в одном и том же режиме может зависеть от того,<br>
применяет ли клиент удаленный ресолвинг. Это может быть неочевидно.<br>
В одной программе работает, в другой - нет.<br>
Если вы используете профиль с хостлистом , и вам нужен mss, укажите mss в профиле с хостлистом,<br>
создайте еще один профиль без хостлиста, если его еще нет, и в нем еще раз укажите mss.<br>
Тогда при любом раскладе будет выполняться mss.<br>
Используйте <code>curl --socks5</code> и <code>curl --socks5-hostname</code> для проверки вашей стратегии.<br>
Смотрите вывод --debug, чтобы убедиться в правильности настроек.</p>
<p>В стандартных скриптах запуска --mss так же копируется в suffix и используется оттуда при <code>MODE_FILTER=hostlist</code>.</p>
<pre><code class="lang-auto">MODE_FILTER=hostlist
TPWS_OPT="--hostspell=HOST --split-http-req=method --split-pos=3 --oob --mss 88"
TPWS_OPT_SUFFIX="--mss 88"
</code></pre>
<p><strong>Это несовместимое изменение 1.</strong><br>
<strong>Несовместимое изменение 2 - удалена опция --mss-pf за ненадобностью. Функция реализована через профили.</strong></p></td><td>2024-09-20T08:42:38.941Z</td></tr><tr><td>bolvan</td><td><p>В blockcheck внесена поддержка переменных<br>
TPWS_EXTRA - для tpws<br>
PKTWS_EXTRA - для nfqws/dvtws/winws<br>
эти переменные добавляются к параметрам тестовых запусков соотв демонов</p>
<p>основное применение - включение разных внешних пейлоадов</p>
<p><code>PKTWS_EXTRA="--dpi-desync-fake-tls=/opt/zapret/files/fake/tls_clienthello_www_google_com.bin" ./blockcheck.sh</code></p>
<p>чтобы не уродовать код скрипта ради сиюминутных частных веяний и хотелок</p></td><td>2024-09-23T05:27:34.400Z</td></tr><tr><td>bolvan</td><td><p>Дополнение к *_EXTRA.</p>
<p>Похоже, что нельзя адекватно в стандартную шелл переменную засунуть множество аргументов командной строки для вызываемого процесса.<br>
Проблема в пробелах.</p>
<p>Допустим, у нас PKTWS_EXTRA=“–hostcase --hostnospace”<br>
Я передаю эту переменную как есть $PKTWS_EXTRA без кавычек в дочерний процесс.<br>
Получается 2 аргумента. Все хорошо.</p>
<p>но что делать, если PKTWS_EXTRA=“–hostcase --dpi-desync-fake-tls=”/opt/xxxx xxx xxx/fake.bin""</p>
<p>Нельзя никак сделать, чтобы стало 2 аргумента. И так, и сяк пробовал. Нет нормального способа разделить корректно. Будет или 1 аргумент, или огрызки, или будут передаваться кавычки как есть в процесс. А это - неправильно и не сработает.</p>
<p>Возможно, есть решение через какие-то внешние стандартные команды, но скрипт затачивается на огрызочный busybox environment. Там нет ничего advanced. И баша тоже нет.</p>
<p>Решение такое</p>
<p>PKTWS_EXTRA остается<br>
В него можно совать аргументы через пробел, где в отдельно взятом аргументе нет пробелов.<br>
Если пробелы есть или просто так по желанию можно использовать PKTWS_EXTRA_1 , PKTWS_EXTRA_2, … , PKTWS_EXTRA_9</p>
<p>корректно будет так :</p>
<p>PKTWS_EXTRA_1=“–hostcase” PKTWS_EXTRA_2=“–dpi-desync-fake-tls=/opt/xxxx xxx xxx/fake.bin” ./blockcheck.sh</p>
<p>Если у вас cygwin, то обратные слэши не подходят. Надо обратные слэши в пути перевернуть в прямые. Или использовать cygwin пути : /cygdrive/x/path/to/file.bin.<br>
В скриптах для автоматизации конверсии путей надо использовать команду cygpath.<br>
Пример cygpath есть в blockcheck.cmd</p>
<p>Аналогичная схема реализована и для TPWS_EXTRA</p></td><td>2024-10-02T08:33:14.520Z</td></tr><tr><td>bolvan</td><td><p>Сделал проверку в blockcheck на уже запущенные процессы zapret и вывод предупреждения, если они есть.<br>
Только предупреждение. Блокчек ничего не знает об install_easy, о способе запуска этих процессов, не знает ничего о службах systemd, openrc, sysv, ничего не будет останавливать и трогать. Только warning.<br>
Наличие процессов может свидетельствовать о неободимости остановить службу zapret, а может ни о чем не свидетельствовать. Например, болтается инстанс на порт wireguard или tpws --socks.<br>
Сами думайте надо ли что-то делать или нет.</p>
<p>Сделал еще детект goodbyedpi. Он тоже будет мешать блокчеку</p></td><td>2024-10-02T09:45:39.934Z</td></tr><tr><td>bolvan</td><td><blockquote>
<p>-filter-udp=50000-65535 --dpi-desync=fake,tamper --dpi-desync-any-protocol --dpi-desync-autottl=2 --dpi-desync-repeats=11</p>
</blockquote>
<p>отсутствие понимания создает огромную проблему, и она множится от копипасты<br>
запрет не будет думать за вас<br>
он будет срать 11 пакетами на каждый реальный как вы ему и сказали<br>
причем не только на дискорд<br>
торентики в 10 раз замедлились на раздачу ? вот поэтому, что вы трэш написали</p>
<p>desync any protocol  нуждается в connbytes или  cutoff ограничителе.<br>
пример взят  c винды, где connbytes нет</p>
<p>в добавок в этом примере tamper - лишний. он работает пока только с DHT.<br>
а так же autottl не будет работать на всех провайдерах. или вообще, или потребуется поиск рабочей delta. Для каких-то протоколов это не так важно, потому что сервер отбрасывает невалидные пакеты, даже если они до него дошли. Типичный пример - QUIC. А для других может испортить что-то.<br>
Поскольку нет фильтра по IP, а только по портам, то насиловаться будут все udp с портами 50000+. И что-то может сломаться. Совершенно неожиданно и внезапно.</p></td><td>2024-10-10T05:09:56.686Z</td></tr><tr><td>bolvan</td><td><p>Добавлена поддержка множественных custom скриптов в директориях custom.d</p>
<details>
<summary>
Спойлер</summary>
<h2><a name="p-53391-custom-1" class="anchor" href="#p-53391-custom-1"></a>Вариант custom</h2>
<p>custom код вынесен в отдельные shell includes.<br>
Поддерживается старый вариант в<br>
/opt/zapret/init.d/sysv/custom<br>
/opt/zapret/init.d/openwrt/custom<br>
/opt/zapret/init.d/macos/custom<br>
Он считается устаревшим. Актуальный вариант - помещать отдельные скрипты там же, но в директорию “custom.d”.<br>
Она будет просканирована стандартным образом, т.е. в алфавитном порядке, и каждый скрипт будет применен.<br>
Рядом имеется “custom.d.examples”. Это готовые скрипты, которые можно копировать в “custom.d”.<br>
Особо стоит отметить “10-inherit-*”. Они наследуют стандартные режимы nfqws/tpws/tpws-socks.<br>
Полезно, чтобы не писать код заново. Достаточно лишь скопировать соответствующий файл.<br>
Можно наследовать и более сложным образом.<br>
“10-inherit-tpws4http-nfqws4https” наследует для http tpws, а для https и quic - nfqws.</p>
<p>Для linux пишется код в функции<br>
zapret_custom_daemons<br>
zapret_custom_firewall<br>
zapret_custom_firewall_nft</p>
<p>Для macos<br>
zapret_custom_daemons<br>
zapret_custom_firewall_v4<br>
zapret_custom_firewall_v6</p>
<p>zapret_custom_daemons поднимает демоны nfqws/tpws в нужном вам количестве и с нужными вам параметрами.<br>
Для систем традиционного linux (sysv) и MacOS в первом параметре передается код операции : 1 = запуск, 0 = останов.<br>
Для openwrt логика останова отсутствует за ненадобностью.<br>
Схема запуска демонов в openwrt отличается - используется procd.</p>
<p>zapret_custom_firewall поднимает и убирает правила iptables.<br>
В первом параметре передается код операции : 1 = запуск, 0 = останов.</p>
<p>zapret_custom_firewall_nft поднимает правила nftables.<br>
Логика останова отсутствует за ненадобностью.</p>
<p>Если вам не нужны iptables или nftables - можете не писать соответствующую функцию.</p>
<p>В linux можно использовать локальные переменные FW_EXTRA_PRE и FW_EXTRA_POST.<br>
FW_EXTRA_PRE добавляет код к правилам ip/nf tables до кода, генерируемого функциями-хелперами.<br>
FW_EXTRA_POST добавляет код после.</p>
<p>В linux функции-хелперы добавляют правило в начало цепочек, то есть перед уже имеющимися.<br>
Поэтому специализации должны идти после более общих вариантов.<br>
Поэтому наследования идут с префиксом 10, а остальные custom скрипты с префиксом 50.<br>
Допустим, у вас есть особые правила для IP подсети youtube. Порты те же самые.<br>
Включен и общий обход. Чтобы youtube пошел приоритетом, скрипт должен применяться после<br>
общего обхода.<br>
Для macos правило обратное. Там правила добавляются в конец. Поэтому inherit скрипты<br>
имеют префикс 90.</p>
<p>В macos firewall-функции ничего сами никуда не заносят. Их задача - лишь выдать текст в stdout,<br>
содержащий правила для pf-якоря. Остальное сделает обертка.</p>
<p>Особо обратите внимание на номер демона в функциях “run_daemon” и “do_daemon”, номера портов tpws<br>
и очередей nfqueue.<br>
Они должны быть уникальными во всех скриптах. При накладке будет ошибка.<br>
Поэтому используйте функции динамического получения этих значений из пула.</p>
<p>custom скрипты могут использовать переменные из config. Можно помещать в config свои переменные<br>
и задействовать их в скриптах.<br>
Можно использовать функции-хелперы. Они являются частью общего пространства функций shell.<br>
Полезные функции можно взять из примеров скриптов. Так же смотрите “common/*.sh”.<br>
Используя хелпер функции, вы избавитесь от необходимости учитывать все возможные случаи<br>
типа наличия/отсутствия ipv6, является ли система роутером, имена интерфейсов, …<br>
Хелперы это учитывают, вам нужно сосредоточиться лишь на фильтрах {ip,nf}tables и<br>
параметрах демонов.</p>
</details>
<p>Сделаны экспериментальные custom скрипты 50-discord.<br>
Автор не изучал блокировку этого сервиса. Сделано с информации community.<br>
Можете дополнять, изменять и оптимизировать.</p></td><td>2024-10-12T10:23:24.620Z</td></tr><tr><td>bolvan</td><td><p>Сделаны скрипты получения листов get_refilter_ipsum.sh, get_refilter_domains.sh</p>
<aside class="onebox allowlistedgeneric" data-onebox-src="https://habr.com/ru/articles/850292/">
  <header class="source">
      <img src="zapret-whats-new-61/e8fc7b34a1237fbc93fd62548efc1a4df1f7fa72.png" class="site-icon" data-dominant-color="97BFD2" width="16" height="16">

      <a href="https://habr.com/ru/articles/850292/" target="_blank" rel="noopener">Хабр</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/361;"><img src="zapret-whats-new-61/1557834368779be24e277f5ec0be00056e71ef49_2_690x389.jpeg" class="thumbnail" data-dominant-color="F4F5F5" width="690" height="389"></div>

<h3><a href="https://habr.com/ru/articles/850292/" target="_blank" rel="noopener">Альтернативный список заблокированных в РФ ресурсов Re:filter</a></h3>

  <p>В этой статье я хочу описать проблему с которой я столкнулся будучи пользователем существующих списков заблокированных ресурсов, шаги к решению и результаты работы. Статья в меньшей степени...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>
<aside class="onebox githubrepo" data-onebox-src="https://github.com/1andrevich/Re-filter-lists">
  <header class="source">

      <a href="https://github.com/1andrevich/Re-filter-lists" target="_blank" rel="noopener">github.com</a>
  </header>

  <article class="onebox-body">
    <div class="github-row" data-github-private-repo="false">
  <img width="690" height="344" src="zapret-whats-new-61/b1fc6abcf90b039b5ca7598bcbcf4401b1ab330f_2_690x344.png" class="thumbnail" data-dominant-color="EAECED">

  <h3><a href="https://github.com/1andrevich/Re-filter-lists" target="_blank" rel="noopener">GitHub - 1andrevich/Re-filter-lists: Re:filter is (an attempt to create) an actual list...</a></h3>

    <p><span class="github-repo-description">Re:filter is (an attempt to create) an actual list of blocked domains and IPs in RU + popular and blocked for RU users </span></p>
</div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Если вкратце, то это интеллектуальная попытка расчистить нарко-казиношный трэш из реестра</p></td><td>2024-10-15T12:30:01.143Z</td></tr><tr><td>bolvan</td><td><p>Сделаны ipset-ы в tpws и nfqws. User mode реализация, которая ни в коей мере не должна быть использована как удобная замена сложным ковыряниям в ip/nf tables лишь потому, что это просто и удобно. Это будет порочной практикой. Сделано для систем windows и linux без ipset (Android, например)</p>
<p>ipset-ами фильтруются профили. ipset является жестким фильтром, он работает сразу после первого пакета.</p>
<p>Поддержка фильтрации L7 (–filter-l7). L7 протокол становится известен обычно после первого пакета с данными вместе с hostname. Поэтому он не работает для нулевой фазы. На нулевой фазе L7 всегда равен unknown.</p>
<p>autohostlist debug log теперь содержит ip:port клиента и название L7 протокола. В postnat режиме вы не увидите ip клиента, а увидите endpoint самого роутера, с которого идет внешний конект.</p>
<p>custom scripts<br>
Переменные FW_EXTRA_PRE, FW_EXTRA_POST для добавления строчки в nft rule или iptables rule до и после правила zapret. Можно использовать как локальные переопределения для одной или более операций в своих custom скриптах.<br>
Например, вам очень нужно дурить DPI только для клиентов с одной подсети. Если используется postnat режим, сначала надо маркировать пакеты каким-то битом, не конфликтующим с nfqws, а<br>
затем добавлять фильтр по mark.</p>
<p>Чтобы исключить конфликты по номерам портов , демонов и очередей введена динамическая аллокация через хелперы alloc_dnum, alloc_qnum alloc_tpws_port.</p>
<p>Новая функция zapret_custom_firewall_nft_flush предназначена для зачистки своих цепочек и set-ов. Нужна только, если таковые есть. Стандартные цепочки zapret чистятся автоматически.</p>
<p>Новые скрипты получения ip и host листов get_refilter_ipsum.sh , get_refilter_domain.sh</p>
<p>Багфиксы.<br>
Зависание tpws/nfqws с 100% cpu usage, если хостлист в gzip и содержит комментарий.<br>
Исправлено применение autottl при смене профиля на лету.<br>
tpws: исправлено не-применение MSS в transparent proxy mode.</p>
<p>zapret-win-bundle. Обновлен preset-russia на поддержку discord voice. Фильтруется по портам и ipset.<br>
Добавлен killall.exe и reload_lists.cmd для перечитки листов без убивания процесса. Может не работать с сервисом и scheduled task !</p>
<p>32-битная версия под windows : <a href="https://github.com/bol-van/zapret-win32" class="inline-onebox">GitHub - bol-van/zapret-win32</a></p></td><td>2024-10-16T13:04:48.705Z</td></tr><tr><td>bolvan</td><td><p>Сделан минимальный вариант запуска tpws на openwrt для систем с ограниченным местом на диске.<br>
init.d/openwrt-minimal<br>
Требования к диску от 120 до 200 кб. 200 кб - для iptables и ipv6</p>
<p>Управление конфигом tpws через UCI : /etc/config/tpws. Управление фаерволом через файлы /etc/firewall.user для iptables и /etc/nftables.d/90-tpws.nft  для nftables</p></td><td>2024-10-21T18:57:52.116Z</td></tr><tr><td>bolvan</td><td><p>Собираюсь убирать все это хозяйство с HTTP,HTTPS,QUIC,MODE<br>
Оно создавалось под вариант, когда не было мультистратегий и фильтров.<br>
Сейчас натягивают сову на глобус, пытаясь запихнуть в QUIC незапихуемое только потому, что там udp. Это полнейший misuse и трэш.<br>
Будет несовместимое изменение, полностью ломающее старый конфиг.<br>
Конфигурация будет приближена к winws.<br>
Отдельно настраиваем перехват по портам и отдельно опции единственного инстанса nfqws и/или tpws.<br>
Стандартный autohostlist будет в виде переменной $AUTOHOSTLIST, стандартный hostlist - $HOSTLIST. Куда надо, туда и воткнете. Будете сами думать куда. Как в винде.<br>
Скачивание сетов/листов будет отдельно настраиваться.</p>
<p>Кастомы останутся, но уже без MODE=custom. Достаточно их наличия.<br>
Могут быть варианты, не вписывающиеся даже в новую схему.<br>
Тот же дискорд требует особого ipset. Проводить в конфиг - это слишком частно, такого не будет.<br>
На винде ipset идет через параметр --ipset winws, а на не винде это порочная практика. Естественно, по незнанию и по упрощению будут насиловать несвойственным образом, но это ненормально. Надо использовать kernel ipsets.<br>
Думаю воткну в инсталятор проверку на наличие параметра --ipset и принудительный отказ продолжать. Иначе один кто-то напишет, а потом по сети этот копипастный трэш будет распространяться.</p></td><td>2024-10-22T05:27:14.310Z</td></tr><tr><td>bolvan</td><td><p>Масштабное переосмысление системы запуска под linux,openwrt,macos.<br>
Конфиг потерял совместимость.<br>
Инсталлятор при замещении /opt/zapret будет предупреждать о несовместимости параметров и отказываться их сохранять. Придется настраивать заново.</p>
<p>Основная причина рефакторинга - приведение конфига к функции мульти-стратегий.<br>
Больше не надо разделять на инстансы http, quic и прочее.<br>
Не надо натягивать сову на неестественные места. В сети распространились конфиги, где дискорд пытаются засунуть в QUIC.</p>
<p>Больше нет никаких http, https, quic.<br>
Есть отдельно настраиваемые параметры запуска tpws, tpws-socks, nfqws и параметры перехвата трафика через ядро (iptables, nftables).<br>
Очень похоже на вариант winws на windows.<br>
Параметра MODE тоже больше нет. Стандартные режимы имеют свои выключатели и включаются независимо, а custom scripts применяются просто по факту их наличия в custom.d<br>
Можно легко комбинировать tpws и nfqws вместе, и потом на эту систему подвесить еще tpws socks для получения обходного прокси.</p>
<p>custom скрипты <em>inherit</em> больше не нужны. Если их не убрать, будет рекурсивное зацикливание.</p>
<p>Применение стандартных хостлистов идет через маркер <code>&lt;HOSTLIST&gt;</code> в конфиге. Скрипты подставляют на его место фактические параметры листов из ipset в зависимости от MODE_FILTER и убирают, если не задана фильтрация по хостлистам.</p>
<p>Особо читайте раздел “Выбор параметров” в readme.txt, а так же docs/quick_start.txt.</p></td><td>2024-10-25T11:59:51.462Z</td></tr><tr><td>bolvan</td><td><p>Еще одно слабое место остается в nfqws и tpws.<br>
При дублировании хостлистов по профилям они дублируются и в  памяти.<br>
Если листы большие - занимаемая память увеличивается кратно.<br>
Так сделано из-за обьединения всех листов одного типа.<br>
Если 1 профиль имеет хостлист a и b, а другой имеет b, то фактически это разные хостлисты в памяти, поскольку список “a+b” - не a и не b. Там не отделить одно от другого.<br>
Надо хранить все листы в памяти раздельно и проверять несколько штук в 1 профиле тоже раздельно. И делать дедупликацию. Не загружать заново.<br>
Аналогично и с ipset</p></td><td>2024-10-25T15:56:56.134Z</td></tr><tr><td>bolvan</td><td><p>В blockcheck сделана поддержка DoH.<br>
Она включается автоматически, если обнаружена подмена DNS.<br>
Чтобы включить или выключить принудительно, можно использовать переменную<br>
SECURE_DNS=0|1<br>
В код зашит список из 5 открытых ресолверов DoH. Проверяются все по очереди до первого работающего. Этот и используется.<br>
Переопределить список для поиска можно в переменной DOH_SERVERS. Задать конкретный сервер можно через DOH_SERVER.</p>
<p>Технически ресолвинг опирается на обновленный mdig и выполняется так :<br>
<code>mdig --family=6 --dns-make-query=rutracker.org | curl --data-binary @- -H "Content-Type: application/dns-message" https://cloudflare-dns.com/dns-query | mdig --dns-parse-query</code></p>
<p>Поэтому он не требует никакого специального софта и может работать на openwrt без плясок.<br>
Встроенная поддержка doh в curl может во-первых не быть, во-вторых он будет каждый раз призадумываться. В blockcheck сделано кэширование DNS записей, и этот вариант не очень сочетается.</p></td><td>2024-10-26T14:54:20.690Z</td></tr><tr><td>bolvan</td><td><p>В blockcheck сделана фильтрация только по IP:port тестируемого в настоящий момент домена.<br>
Все остальное больше не трогается. Не рушит на час работу броузера.</p></td><td>2024-10-27T16:32:54.229Z</td></tr><tr><td>bolvan</td><td><p>upcoming release 67 notes</p>
<p>Самое главное изменение - переделана система внутреннего управления листами в nfqws и tpws.<br>
Если раньше листы одного профиля кидались в общую неделимую кучу и загружались заново для каждого следующего профиля, то теперь листы все загружаются отдельно, исключая повторы.<br>
Если раньше вы писали <code>&lt;HOSTLIST&gt;</code> в 3 профилях и использовали большой РКН лист, то требуемая память умножалась на 3 и могла доходить до внушительных для слабых систем значений. Теперь это больше не так.</p>
<details>
<summary>
Спойлер</summary>
<pre><code class="lang-auto">--filter-tcp=80 --dpi-desync=fake,split2 --dpi-desync-fooling=md5sig &lt;HOSTLIST&gt; --new \
--filter-tcp=443 --dpi-desync=fake,disorder2 --dpi-desync-fooling=md5sig &lt;HOSTLIST&gt; --new \
--filter-udp=443 --dpi-desync=fake --dpi-desync-repeats=6 &lt;HOSTLIST&gt; --debug

lists summary:
hostlist file /opt/zapret/ipset/zapret-hosts-user-exclude.txt
hostlist file /opt/zapret/ipset/zapret-hosts.txt.gz
hostlist file /opt/zapret/ipset/zapret-hosts-user.txt
profile 1 include hostlist /opt/zapret/ipset/zapret-hosts.txt.gz
profile 1 include hostlist /opt/zapret/ipset/zapret-hosts-user.txt
profile 1 exclude hostlist /opt/zapret/ipset/zapret-hosts-user-exclude.txt
profile 2 include hostlist /opt/zapret/ipset/zapret-hosts.txt.gz
profile 2 include hostlist /opt/zapret/ipset/zapret-hosts-user.txt
profile 2 exclude hostlist /opt/zapret/ipset/zapret-hosts-user-exclude.txt
profile 3 include hostlist /opt/zapret/ipset/zapret-hosts.txt.gz
profile 3 include hostlist /opt/zapret/ipset/zapret-hosts-user.txt
profile 3 exclude hostlist /opt/zapret/ipset/zapret-hosts-user-exclude.txt
</code></pre>
</details>
<p>Кроме того сделана автоматическая перечитка всех листов при изменении времени модификации файлов. HUP больше не нужен.<br>
Исчезновение какого-либо файла листа или потеря доступа к нему больше не является фатальной проблемой. Раньше демоны в этом случае аварийно завершались. Сейчас в этой ситуации ничего страшного не случится. Будет использоваться копия в памяти. При появлении файла или возобновлении доступа он опять будет проверен на время изменения и при необходимости перегружен.<br>
Перегрузка выполняется не сразу, а только по факту использования данного листа.</p>
<p>Все сказанное полностью распространяется и на user mode ipsets.</p>
<p>Параметры <code>--filter-tcp</code>, <code>--filter-udp</code> теперь берут список портов или диапазонов портов через запятую.<br>
Особый знак <code>*</code> есть синоним 1-65535.</p>
<p>В конфиге в опциях tpws и nfqws введен еще 1 маркер <code>&lt;HOSTLIST_NOAUTO&gt;</code>.<br>
Он аналогичен <code>&lt;HOSTLIST&gt;</code>, только <code>ipset/zapret-hosts-auto.txt</code> для текущего профиля вставляется как обычный лист, что позволяет выключить логику распознавания блокировок.<br>
Если другой профиль обновил автолист, остальные профили принимают изменения автоматически, поскольку теперь это хранится в одной области памяти без дублирования.</p>
<p>blockcheck теперь дурит только IP:port тестируемого домена. Все остальное не затрагивается.<br>
Введена поддержка DoH серверов, которая включается автоматически при обнаружении подмены DNS.<br>
Элевация до рута сохраняет переменные исходного юзера. Больше не надо получать сначала рутовый шелл, чтобы скармливать переменные blockcheck.<br>
blockcheck не проводит элевацию до рута, если SKIP_PKTWS=1 или система MacOS (тк там всегда только tpws)</p>
<p>Репозиторий zapret-win32 удален. Его содержимое перемещено в основной репозиторий в binaries/win32.<br>
win64/zapret-winws так же удален. Его содержимое осталось только в zapret-win-bundle.</p>
<p>nfqws: исправлено вероятное падение при включении опций --hostcase, --hostnospace, --domcase</p>
<p>В nfqws, tpws поддерживается чтение конфига из файла через первый и единственный параметр @&lt;config_file&gt;</p></td><td>2024-10-29T18:46:01.718Z</td></tr><tr><td>bolvan</td><td><p>release 68</p>
<p>Удалены binaries. Binaries теперь только в релизах, собираемых через github actions.<br>
Русская документация переведена в markdown.<br>
nfqws,tpws: альтернативное использование знака ‘$’ для чтения параметров запуска из файла :$&lt;config_file&gt;<br>
uninstall_easy.sh: предложение удалить зависимости на openwrt<br>
install_easy.sh: предложение скачивать хостлисты в режиме фильтрации autohostlist<br>
Багфиксы</p>
<p>На традиционных *nix платформах по-прежнему можно использовать основную репу без бинариков. Их можно собрать самому, имея <code>cc</code>, <code>make</code> и необходимые dev пакеты : <code>zlib1g-dev libcap-dev libnetfilter-queue-dev</code>. <code>install_easy.sh</code> при отсутствии бинариков сам запустит make. Но установка dev пакетов и компилятора - на вас.<br>
Так же актуализирована и дока по сборке на openwrt под SDK в <code>docs/compile</code></p></td><td>2024-11-08T08:55:58.564Z</td></tr><tr><td>bolvan</td><td><h3><a name="p-68015-zapret-v69-1" class="anchor" href="#p-68015-zapret-v69-1"></a>zapret v69</h3>
<ul>
<li>nfqws,tpws : поддержка сплита на нескольких позициях : <code>multisplit</code> и <code>multidisorder</code></li>
<li>nfqws : переименование <code>split</code> =&gt; <code>fakedsplit</code> , <code>disorder</code> =&gt; <code>fakeddisorder</code>. старые варианты остаются как синонимы.</li>
<li>nfqws : депрекация <code>--dpi-desync-split-http-req</code>, <code>--dpi-desync-split-tls</code>. старые параметры добавляют split позиции к списку.</li>
<li>nfqws : <code>split2</code> и <code>disorder2</code> становятся синонимами <code>multisplit</code> и <code>multidisorder</code>. сохраняется автоматическая split позиция 2, если не указано <code>--dpi-desync-split-pos</code>.</li>
<li>nfqws : отмена <code>seqovl</code> без отмены desync в случае превышения MTU. только для Linux.</li>
<li>nfqws : <code>seqovl</code> берет позиционные маркеры для disorder и только число для split</li>
<li>tpws : депрекация <code>--split-http-req</code> , <code>--split-tls</code>. старые параметры добавляют split позиции к списку.</li>
<li>tpws : <code>--tlsrec</code> берет позиционные маркеры, а не только фиксированные смещения</li>
<li>tpws : депрекация <code>--tlsrec-pos</code>. старый параметр создает абсолютный положительный маркер.</li>
<li>tpws : починка не срабатывающего мультисплита через <code>--fix-seg</code></li>
<li>nfqws,tpws : назначение владельца лог файлам и автохостлисту после парсинга всех опций</li>
<li>nfqws,tpws : установка переменной окружения EXEDIR для использования в <code>@config</code></li>
<li>dvtws : установка рандомного поля ip_id вместо нулевого</li>
<li>repo : бинарники для android API level 21+ (Android 5.0)</li>
<li>install_easy : поддержка APK packet manager в openwrt</li>
<li>blockcheck : убран вопрос “игнорировать сертификаты”</li>
<li>blockcheck : убраны переменные IGNORE_CA, CURL_VERBOSE. вместо них добавлена переменная CURL_OPT.</li>
<li>blockcheck : поддержка новых стратегий multisplit</li>
<li>blockcheck : переработка порядка тестирования стратегий</li>
<li>blockcheck : показ всех рабочих стратегий в summary</li>
<li>багфиксы</li>
</ul></td><td>2024-11-19T16:14:59.718Z</td></tr><tr><td>bolvan</td><td><h3><a name="p-68816-zapret-v691-1" class="anchor" href="#p-68816-zapret-v691-1"></a>zapret v69.1</h3>
<ol>
<li>tpws : исправлена логика процессинга хостлистов в режиме --socks5-hostname и логика обработки неизвестного протокола с хостлистами.</li>
<li>10-keenetic-udp-fix : лечащая добавка для кинетика против отсутствия маскарада без ndmmark</li>
</ol>
<h3><a name="p-68816-zapret-v692-2" class="anchor" href="#p-68816-zapret-v692-2"></a>zapret v69.2</h3>
<ul>
<li>nfqws,tpws: новый параметр <code>--skip</code> для временного исключения профиля без удаления параметров</li>
<li>nfqws: новый параметр <code>--methodeol</code>. убрать пробел после <code>Host:</code> и добавить <code>\n</code> перед методом</li>
<li>init.d: не использовать pgrep в sysv для совместимости с busybox (keenetic, прошивки, alpine)</li>
</ul></td><td>2024-11-23T10:55:18.701Z</td></tr><tr><td>bolvan</td><td><p>zapret v69.4</p>
<ul>
<li>nfqws: обрамление фейками обоих сегментов в fakedsplit/fakeddisorder</li>
<li>nfqws: задание содержимого фейков в fakedsplit/fakeddisorder через --dpi-desync-fakedsplit-pattern</li>
<li>багфиксы</li>
</ul>
<p>На некоторых операторах такой зоопарк, что без обрамления обоих сегментов fakedsplit не пробивает.<br>
Долго думал почему. Резал и по midsld. Нифига не работало.<br>
Как он определяет какие фейки, какие нет, если все идет подряд с одинаковой длиной и sequence, а во втором куске нет полного имени хоста ? Но по факту если второй кусок тоже облепить, то работает</p></td><td>2024-11-24T14:45:57.241Z</td></tr><tr><td>bolvan</td><td><p>zapret v69.5</p>
<ul>
<li>nfqws,tpws: опция проверки параметров командной строки без фактического запуска --dry-run</li>
<li>install_easy: проверка параметров командной строки tpws и nfqws</li>
</ul></td><td>2024-12-03T15:45:03.526Z</td></tr><tr><td>bolvan</td><td><p>zapret v69.6</p>
<ul>
<li>nfqws: Установка NETLINK_NO_ENOBUFS для NFQUEUE. Решает проблему с аварийным выходом процесса на некоторых системах (keenetic).</li>
<li>init.d: Унификация custom скриптов для linux. Удалены init.d/{openwrt,sysv}/custom.d.examples. Скрипты теперь имеют формат как раньше для sysv, примеры находятся в `init.d/custom.d.examples.linux’. Совместимость со старым openwrt вариантом сохраняется. Но копипастные инструкции немного слетят.</li>
<li>init.d: Новый custom скрипт 20-fw-extra. Например, для тех, кому нужно дурить трафик через nfqws только с одного входящего интерфейса и не дурить с остальных.</li>
<li>init.d: Новый custom скрипт 50-wg4all. Ищет в ядре udp пакеты wireguard handshake initiation на любые порты и перенаправляет на nfqws.</li>
</ul>
<p>Пояснения на счет 20-fw-extra.<br>
Меня не раз спрашивали что делать, если надо дурить на nfqws только одну внутреннюю сеть, а другую нет. Чтобы был публичный wifi с ограничениями и непубличный wifi для своих, например. Обычно я предлагал отказаться от скриптов и запускать руками.<br>
Но теперь эта задача может быть решена и на уровне скриптов.<br>
Главная проблема - отсутствие возможности в стандартном варианте задавать свои условия ip/nf tables. Вторая проблема - невозможность фильтрации по внутренним IP в варианте nftables при использовании схемы postnat.<br>
Задача решается примерно так :</p>
<ol>
<li>Разнести их на разные подсети и интерфейсы. Так проще будет понять нужно ли им дурение. Хотя, если вы можете назначать “своим” особые IP адреса, можно и по ним тоже сечь.</li>
<li>Сделать NFQWS_ENABLE=0 в config.</li>
<li>Переписать <code>init.d/custom.d.examples.linux/20-fw-extra</code> в <code>custom.d</code></li>
<li>Настроить config :</li>
</ol>
<pre><code class="lang-auto">NFQWS_ENABLE_OVERRIDE=1
FW_EXTRA_PRE_NFQWS_IPT="-m mark --mark 0x10000000/0x10000000"
FW_EXTRA_PRE_NFQWS_NFT="mark and 0x10000000 != 0"
</code></pre>
<ol start="5">
<li>Отдельными средствами маркировать битом 0x10000000 пакеты, предназначенные для дурения на этапе до POSTROUTING. Для проходящего трафика это можно сделать в PREROUTING, для исходящего с самой системы - в OUTPUT.</li>
</ol>
<p>50-wg4all - это простое решение для дурения любого wireguard, не требующее настройки по портам и чему-либо еще. Переписал и работает. Оверхеда на системе практически не создает.<br>
Единственная возможная настройка - стратегия дурения в config : <code>NFQWS_OPT_DESYNC_WG</code>.<br>
По умолчанию - <code>--dpi-desync=fake</code>. Туда можно добавить репиты по необходимости.</p></td><td>2024-12-09T11:10:01.247Z</td></tr><tr><td>bolvan</td><td><p>zapret v69.7</p>
<ul>
<li>nfqws,tpws: параметр --comment. любые комментарии в любом месте.</li>
<li>nfqws: предупреждение о возможной “ТРЭШ ФЛУД” конфигурации. Когда пишите --dpi-desync-any-protocol без --dpi-desync-cutoff и используете методы с фейками. Это не всегда плохо, но когда плохо, то очень плохо.</li>
<li>winws: многократное снижение использования процессора за счет отказа от процессинга пустых TCP ACK пакетов в --wf-tcp</li>
<li>nfqws: в android версии исправлен bad system call при завершении процесса</li>
</ul></td><td>2024-12-13T16:39:06.140Z</td></tr><tr><td>bolvan</td><td><h3><a name="p-72747-zapret-v698-1" class="anchor" href="#p-72747-zapret-v698-1"></a>zapret v69.8</h3>
<ol>
<li>winws: обработка пустых исходящих TCP с FIN или RST в --wf-tcp для нужд conntrack</li>
<li>repo: сборка под mips-rlx5281 (lexra)</li>
</ol></td><td>2024-12-15T13:44:12.949Z</td></tr><tr><td>bolvan</td><td><p>Где-то месяца два назад пробовал смотреть почему не работает приложение youtube TV.<br>
Оно использует GQUIC, который zapret не опознает и не реагирует на него.<br>
Думал уже надо делать поддержку GQUIC.<br>
Но поставив свежую версию с apkmirror обнаружил, что GQUIC больше нет, есть IETF QUIC, и все и так работает.<br>
Следовательно страждующим - обновляйте приложение.</p>
<p>У меня заработало вот это<br>
<code>com.google.android.youtube.tv_5.21.300-521300320_minAPI24(armeabi-v7a)(nodpi)_apkmirror.com.apk</code></p>
<p>На эмуляторе genymotion под образом android 12 версия для x64 не работает, но не из-за блокировки, а по причине отсутствия чего-то в системе. Возможно, кодеков. На реальном устройстве заработало без проблем</p>
<p>Делаю вывод, что тратить силы на поддержку GQUIC не имеет смысла, тк протокол устаревший, и используется только в старых версиях отдельных приложений. И есть обновление, которое отказалось от использования этого протокола</p>
<p>Приложение Android TV завелось на чистом Android 9 (не сток) без установленных gapps. Официальные требования - Android 7.0+. Следовательно, могу предположить, что требования не очень мощные, и должно пойти на достаточном количестве устройств. Но должно быть какие-то старые телики и приставки обломаются, поскольку нельзя на них обновить версию приложения.<br>
Android 5.0 поддерживают только старые версии приложения 2.x</p>
<p>Для владельцев старых девайсов можно сделать дурение всего UDP на 443 без листов<br>
<code>--filter-udp=443 --dpi-desync=fake --dpi-desync-any-protocol --dpi-desync-cutoff=d2 --dpi-desync-repeats=СКОЛЬКО_НАДО</code><br>
Хуже не будет</p>
<p>Или отдельно для quic через `–filter-udp=443 --filter-l7=quic", затем вышеописанное</p></td><td>2024-12-21T13:43:01.083Z</td></tr><tr><td>bolvan</td><td><p>В блокчеке 2 нововведения</p>
<ol>
<li>
<p>Переменная PARALLEL=1 включает параллельные попытки тестирования стратегий.  По умолчанию не включается из-за опасности обидеть сайт дятло-долбежкой и получить неверный результат.</p>
</li>
<li>
<p>Возможность задать ответы на диалоговые вопросы через переменные и убрать тем самым эти вопросы. Чтобы сразу запускался процесс и не было вопросов на что-нибудь нажать или что-нибудь ввести.<br>
<code>CURL_MAX_TIME=1 CURL_MAX_TIME_QUIC=2 SKIP_DNSCHECK=1 DOMAINS=nnmclub.to IPVS=46 ENABLE_HTTP=1 ENABLE_HTTPS_TLS12=1 ENABLE_HTTPS_TLS13=1 ENABLE_HTTP3=1 REPEATS=8 PARALLEL=1 SCANLEVEL=standard BATCH=1 ./blockcheck.sh</code></p>
</li>
</ol>
<p>Для использования с релизом достаточно заменить файл blockcheck.sh из git.</p></td><td>2025-01-03T11:08:39.745Z</td></tr><tr><td>bolvan</td><td><p>v70.5</p>
<ul>
<li>nfqws: множественные фейки для всех типов протоколов через указание множественных параметров <code>--dpi-desync-fake-???</code>. (кроме syndata, это - не протокол)</li>
<li>nfqws: поддержка меж-пакетной дефрагментации QUIC фреймов CRYPTO. так стали делать свежие chrome броузеры. на более старой версии пакеты не собираются, хост не вытаскивается</li>
</ul>
<p>Если не обновлять pktws, на последних chrome слетит дурение quic и перестанут работать хостлисты по quic. Либо придется отключать KYBER</p></td><td>2025-03-24T11:55:15.434Z</td></tr>
    </table>
      </body>
    </html>