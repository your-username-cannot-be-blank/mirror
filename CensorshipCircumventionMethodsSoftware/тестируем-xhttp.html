
    <html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <style>
    th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    th, td {
      word-wrap: break-word;
      padding: 5px;
    }
    table {
      width: 100%;
      max-width: 100%;
      border: 1px solid black;
      border-collapse: collapse;
      table-layout: fixed;
      word-wrap: break-word
    }
    code {
      word-wrap: break-word;
    }
    pre {
        white-space: pre-wrap;
    }
    </style>
        <title>тестируем-xhttp</title>
      </head>
      <body>
        <table border="1" width="100%" cellpadding="5">
          <tr>
            <th style="width: 10%;">Ник</th>
            <th>Пост</th>
            <th style="width: 10%;">Дата</th>
          </tr>
    <tr><td>NowAndThen</td><td><p>Популярная панель 3X-UI обновилась до 2.4.9. Наконец-то туда прикрутили хайпуемый авторами Xray протокол XHTTP.</p><aside class="onebox allowlistedgeneric" data-onebox-src="https://github.com/MHSanaei/3x-ui/releases/tag/v2.4.9">
  <header class="source">
      <img src="https://ntc.party/uploads/default/original/2X/b/bad3e5f9ad67c1ddf145107ce7032ac1d7b22563.svg" class="site-icon" data-dominant-color="" width="32" height="32">

      <a href="https://github.com/MHSanaei/3x-ui/releases/tag/v2.4.9" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/344;"><img src="тестируем-xhttp/90d695ca07a96c4f7656f116382b023a95c589c6_2_690x345.png" class="thumbnail" data-dominant-color="EDEFED" width="690" height="345"></div>

<h3><a href="https://github.com/MHSanaei/3x-ui/releases/tag/v2.4.9" target="_blank" rel="noopener nofollow ugc">Release v2.4.9 · MHSanaei/3x-ui</a></h3>

  <p>New

XHTTP: Add "stream-one"
WebSocket: Add heartbeatPeriod
XHTTP: Add "hMaxRequestTimes, hKeepAlivePeriod"
XHTTP: Add "scMaxBufferedPosts"
Xray core v24.12.15

Update &amp; improvement

splithttp to x...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Это, кто не в курсе, переработанный SplitHTTP, который теперь официально переименован в XHTTP. <a href="https://xtls.github.io/en/config/transports/xhttp.html" rel="noopener nofollow ugc">Документацию старую пока выпилили</a>. Там, насколько я помню, говорилось, что он шинкует соединение в салат так, что если вы смотрите потоковое видео, например, то у вас не статичный туннель, а он режет и пересобирает его в набор случайных запросов, так что это со стороны выглядит как интенсивный браузинг. Теперь вместо документации ссылаются на статью:</p>
<p><a href="https://github.com/XTLS/Xray-core/discussions/4113" rel="noopener nofollow ugc">XHTTP: Beyond REALITY</a></p>
<p>Там, полистайте, в топике есть русский перевод. Теперь фокус сместили на раздельные восходящие/нисходяшие потоки и продвинутые сценарии работы через CDN.</p>
<p>Базово, теперь в 3X-UI все работает из коробки. Просто берете свой рабочий конфиг и транспорт меняете на XHTTP. Проверил, работает Reality c чужим доменом, со steal oneself и TLS с fallback.</p>
<p>Минус пока в том, что все популярные клиенты на Sing-Box, а его авторы запрос на поддержку XHTTP дропнули и не известно, будут ли вообще его прикручивать. Поэтому нам остается только V2RayN. Обязательно обновляйте до последнего, чтобы поддержка XHTTP появилась. Плюсом, там теперь есть встроенный русские базы geosite/geoip.</p>
<p>А <a href="https://github.com/2dust/v2rayNG/issues/3795" rel="noopener nofollow ugc">на Android V2RayNG русские базы  прикрутить это тот еще квест</a>. И, честно говоря, работает YT через этот клиент довольно тормознуто, причем не только с XHTTP, но и с “классическими” уже протоколами.</p>
<p>.</p></td><td>2024-12-17T13:16:16.144Z</td></tr><tr><td>Nslookdown</td><td><p>Streisand  уже сделали обнову</p></td><td>2024-12-17T14:10:57.252Z</td></tr><tr><td>luluOne</td><td><p>Подскажите, как для не особо разбирающегося, в чем преимущества перед решением, которое все используют сейчас (“обычный” Reality)? Пока не очень понятно. Кроме того, как я понял, для данного решения обязательно нужен домен, метода с самоподписанным сертификатом недостаточно?</p></td><td>2024-12-17T23:13:24.853Z</td></tr><tr><td>nami</td><td><p>Ребят, подскажите как через 3x-ui сделать что бы dns запросы отправлялись через мой сервер? В настройках xray пробовал настроить, но ничего не работает(</p></td><td>2024-12-18T03:56:33.151Z</td></tr><tr><td>PlavaliZnaem( )</td><td><p>Плюсы, которые я вижу<br>
Использование мультиплексирование и долгоживущих сессий.<br>
Возможность проксирования через любые CDN, уход от gRPC<br>
Разные потоки на аплоад и даунлоад</p>
<p>Домен не обязателен, можно использовать тот же Reality, но с транспортом xhttp. Что за метод с самоподписанными сертификатами - не ясно. Если только для прокcирования через CF</p></td><td>2024-12-18T05:52:53.835Z</td></tr><tr><td>NowAndThen</td><td><aside class="quote no-group" data-username="PlavaliZnaem" data-post="5" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/plavaliznaem/48/8180_2.png" class="avatar"> PlavaliZnaem:</div>
<blockquote>
<p>уход от gRPC</p>
</blockquote>
</aside>
<p>Это не решение, это хак. Cloudflare, как я понял, просто читает gRPC заголовок, а все что ты дальше передаешь, считает gRPC траффиком. Xray просто теперь эксплуатирует эту лазейку, маскируя свой трафик под gRPC. Но не факт, что, если её начнут массово абузить, CF эту дыру не прикроет.</p></td><td>2024-12-18T08:20:54.766Z</td></tr><tr><td>lucretia(lucretia)</td><td><aside class="quote no-group" data-username="NowAndThen" data-post="1" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/letter_avatar_proxy/v4/letter/n/c0e974/48.png" class="avatar"> NowAndThen:</div>
<blockquote>
<p>Базово, теперь в 3X-UI все работает из коробки</p>
</blockquote>
</aside>
<p>А можно на пальцах?  Абсолютно тот же конфиг с риалити беру  и протокол просто меняю на xhttp?<br>
И все? Там появляются дополнительные настройки мне их не трогать (host, path etc)?  Нужно ли включать или отключать настройки какие-то в клиентах? Как вообще проверить работает ли этот xhttp?</p></td><td>2024-12-25T20:48:23.113Z</td></tr><tr><td>nikkymen</td><td><p>Я так и не понял, можно ли использовать XHTTP через CDN с использованием realitySettings, чтобы маскироваться под чужой домен?<br>
Меня reality всем устраивает кроме того, что приходится палить IP сервера.</p></td><td>2024-12-25T21:58:20.272Z</td></tr><tr><td>rewhat</td><td><p>Официальная инструкция не очень понятная. Вроде как на сервере нужно поменять transport на xhttp, и в xhttpSettings добавить path (видимо можно любой вписать? я хз). Ну я прописал xhttp, в nginx и в конфиг xray добавил path, в v2rayn указал xhttp и path (при этом в v2rayn еще есть дополнительные непонятные настройки связанные с xhttp). И короче нифига не работает. В общем если кто в теме, напишите пожалуйста нормальную инструкцию как с реалити с маскировкой под свой сайт, перейти на xhttp, и надо ли оно вообще, так как видимо это решение в основном сделано для работы через cdn.</p></td><td>2024-12-25T22:49:54.997Z</td></tr><tr><td>luluOne</td><td><p>Присоединяюсь, помогите, кто в теме, тем, кто не. Или если уже есть какой-то адекватный гайд - киньте ссылку.</p></td><td>2024-12-26T01:11:03.467Z</td></tr><tr><td>NowAndThen</td><td><p>Все проще некуда. Берете свой рабочий конфиг, на TCP-Vision, например, и в поле Transmission просто вместо TCP выбираете XHTTP. Экспортируете ключик заново и импортируете в клиент. Клиент должен поддерживать XHTTP, под Windows это только V2RayN на сегодня. Настройки TLS или Reality оставляете как есть. Настройки XHTTP тоже по умолчанию. Неважно, чужой сайт вы воруете или свой на Nginx, НИЧЕГО кроме Transmission менять не надо. В Nginx ничего менять не надо. “Покормите собак и не трогайте никакие кнопки” (C).</p>
<p>За CDN не расскажу, не знаю, не настраивал. Есть пока только <a href="https://github-com.translate.goog/XTLS/Xray-core/discussions/4118?_x_tr_sl=auto&amp;_x_tr_tl=en&amp;_x_tr_hl=en&amp;_x_tr_pto=wapp" rel="noopener nofollow ugc">китайские гайды</a>.</p></td><td>2024-12-26T11:23:37.332Z</td></tr><tr><td>naykaminka(Sergey)</td><td><p>Поставил как NowAndThen пишет, количество сессий уменьшилось, значит и  мультиплексирование работает. Хотелось бы конечно понять как подружить с CDN ведь это главная фишка из анонса протокола.</p></td><td>2024-12-26T15:08:48.093Z</td></tr><tr><td>UserWasDeleted</td><td><p>Может кто-то отбъяснить как это вообще работает и что дает? Вот использую я к примеру reality с network:tcp  dest:chtoto.net. Что мне нужно что бы прикрутить XHTTP? Нужен ли свой домен? И что вообще даст переход на XHTTP?</p></td><td>2024-12-26T17:05:07.576Z</td></tr><tr><td>rewhat</td><td><aside class="quote no-group" data-username="NowAndThen" data-post="12" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/letter_avatar_proxy/v4/letter/n/c0e974/48.png" class="avatar"> NowAndThen:</div>
<blockquote>
<p>Все проще некуда</p>
</blockquote>
</aside>
<p>это для 3x ui видимо? Я просто в конфиг xray - streamSettings - network прописал “xhttp”, в v2rayn поменял transport на xhttp, и ничего не работает.</p>
<p>Ну ок, тогда следую инструкции с гитхаба</p>
<blockquote>
<ol>
<li>Независимо от того, используется TLS или REALITY, <strong>обычно в конфигурации XHTTP достаточно указать только <code>path</code>, остальные параметры можно не заполнять</strong>.</li>
</ol>
</blockquote>
<p>Делаю xhttpSettings, прописываю туда path на “/”, и на клиенте тоже. Ну и тоже ничего не работает.</p></td><td>2024-12-26T18:23:05.969Z</td></tr><tr><td>NowAndThen</td><td><p>Я про панель, голый не настраивал.</p></td><td>2024-12-26T18:49:27.421Z</td></tr><tr><td>PlavaliZnaem( )</td><td><p>Я у себя так же настроил xhttp+reality, все работает и пашет. Только выбрал дополнительно stream-one, это, как мне показалось, дало меньше всего открытых tcp-сессий при равных условиях (возможно, что просто показалось).<br>
Но я так и не получил ответа нигде, выбор этого новомодного транспорта повышает/не меняет/уменьшает маскировку в случае использования совместно с Reality?</p></td><td>2024-12-27T05:38:34.712Z</td></tr><tr><td>xray108(Xray108)</td><td><p>Буквально вчера поднял у себя VLESS - XHTTP h3 за nginx. Использовал конфиги отсюда <a href="https://github.com/XTLS/Xray-examples/tree/main/VLESS-XHTTP3-Nginx" class="inline-onebox" rel="noopener nofollow ugc">Xray-examples/VLESS-XHTTP3-Nginx at main · XTLS/Xray-examples · GitHub</a><br>
Разве что stream-one изменил на stream-up.<br>
Работает очень шустро я сказал бы, но полноценные тесты пока не проводил</p></td><td>2024-12-27T07:01:01.741Z</td></tr><tr><td>1unknown(Unknown)</td><td><p>XHTTP возможен только со своим доменом?</p></td><td>2024-12-27T17:43:05.611Z</td></tr><tr><td>NowAndThen</td><td><p>Не обязательно.</p></td><td>2024-12-27T18:19:12.617Z</td></tr><tr><td>MasterYoba</td><td><p>Кто-нибудь пробовал настроить с fallbackом на network tcp? Чтобы можно было к reality серверу подключаться как с клиентов с поддержкой xhttp так и без поддержки (напр. sing-box)</p></td><td>2024-12-27T19:35:25.854Z</td></tr><tr><td>1unknown(Unknown)</td><td><p>Можно сделать так ничего не трогая?</p>
<details>
<summary>
Спойлер</summary>
<p><div class="lightbox-wrapper"><a class="lightbox" href="тестируем-xhttp/25334c3475e2bb41de0c1e003eb4e9be969519ba.png" data-download-href="https://ntc.party/uploads/default/25334c3475e2bb41de0c1e003eb4e9be969519ba" title="image"><img src="тестируем-xhttp/25334c3475e2bb41de0c1e003eb4e9be969519ba_2_311x500.png" alt="image" data-base62-sha1="5j5zpzFTQfGHX4sztWQMgwux8Ei" width="311" height="500" srcset="тестируем-xhttp/25334c3475e2bb41de0c1e003eb4e9be969519ba_2_311x500.png, тестируем-xhttp/25334c3475e2bb41de0c1e003eb4e9be969519ba_2_466x750.png 1.5x, тестируем-xhttp/25334c3475e2bb41de0c1e003eb4e9be969519ba.png 2x" data-dominant-color="181B1D"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg><span class="filename">image</span><span class="informations">518×831 23.8 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use href="#discourse-expand"></use></svg></div></a></div></p>
</details></td><td>2024-12-27T22:46:49.178Z</td></tr><tr><td>NowAndThen</td><td><aside class="quote no-group" data-username="MasterYoba" data-post="21" data-topic="13855" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/masteryoba/48/6182_2.png" class="avatar"> MasterYoba:</div>
<blockquote>
<p>Кто-нибудь пробовал настроить с fallbackом на network tcp? Чтобы можно было к reality серверу подключаться как с клиентов с поддержкой xhttp так и без поддержки (напр. sing-box)</p>
</blockquote>
</aside>
<p>Я такое на Reality сделал. Первый инбаунд, например, XHTTP слушает 443, в поле Dest пишем ему какой-нибудь внутренний порт или юникс-сокет. Этот порт/сокет слушает следующий инбаунд, например, на gRPC, в Dest новый порт, который слушает третий инбаунд, пусть на TCP.  Если надоело в эти цепочки играть, терминируем последний через тот же Dest на воруемый сайт или свой домен, как обычно. Т.е. мы по очереди перебираем протоколы, если какой-то подошел ключом, устанавливаем туннель, а если ни один не подцепил, с последнего перебрасываем на сайт. В результате по всем протоколам можно ходить через 443. TLS c fallback, как я понимаю, так же должен работать. Попробуйте такую цепочку через поле Dest в fallback построить, оно ту же функцию по идеее выполняет.</p></td><td>2024-12-27T23:02:47.717Z</td></tr><tr><td>MasterYoba</td><td><p>Настроил. Оказалось очень просто, при уже имеющемся инбаунде для “классического” vless-reality на 443 порте нужно добавить новый инбаунд:</p>
<pre><code class="lang-auto">        {
            "listen": "@xhttp",
            "protocol": "vless",
            "settings": {
                "decryption": "none",
                "clients": [
                    {
                        "id": "ваш_id",
                        "email": "12345"
                    }
                ]
            },
            "streamSettings": {
                "network": "xhttp",
                "xhttpSettings": {
                    "path": "/ваш_path"
                }
            },
            "sniffing": {
                "enabled": true,
                "destOverride": [
                    "http",
                    "tls",
                    "quic"
                ]
            }
        }
</code></pre>
<p>И добавить его в фоллбеки у vless-reality:</p>
<pre><code class="lang-auto">      "settings": {
        "fallbacks": [
          {
            "dest": "@xhttp"
          }
        ]
      },
</code></pre>
<p>И теперь клиенты могут подключаться к reality серверу как c транспортом tcp (raw), так и с xhttp</p></td><td>2024-12-28T09:54:08.900Z</td></tr><tr><td>rewhat</td><td><p>Типа такого?</p>
<details>
<summary>
Спойлер</summary>
<pre data-code-wrap="json"><code class="lang-json">{
  "inbounds": [
    {
      "port": 443,
      "protocol": "vless",
      "settings": {
        "clients": [
          {
            "id": "12345",
            "flow": "xtls-rprx-vision",
            "level": 0,
            "email": "555@555.com"
          }
        ],
        "decryption": "none",
        "fallbacks": [
          {
            "dest": "1111"
          },
          {
            "dest": "@xhttp"
          }
        ]
      },
      "streamSettings": {
        "fingerprint": "chrome",
        "network": "raw",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "1111",
          "xver": 0,
          "serverNames": [
            "example.com"
          ],
          "privateKey": "123",
          "shortIds": [
            "123"
          ]
        }
      },
      "sniffing": {
        "routeOnly": true,
        "enabled": true,
        "destOverride": [
          "http",
          "tls",
          "quic"
        ]
      }
    },
    {
      "listen": "@xhttp",
      "protocol": "vless",
      "settings": {
          "decryption": "none",
          "clients": [
              {
                  "id": "тот же id что у reality",
                  "email": "тот же email что у reality"
              }
          ]
      },
      "streamSettings": {
          "network": "xhttp",
          "xhttpSettings": {
              "path": "/"
          }
      },
      "sniffing": {
        "routeOnly": true,
          "enabled": true,
          "destOverride": [
              "http",
              "tls",
              "quic"
          ]
      }
    }
  ]
}
</code></pre>
</details>
<p>Потом в v2rayN изменяю transport на xhttp, и в Path указываю /.</p>
<p>Ну и опять не работает. Чёт вообще этой темы не выкупаю.</p></td><td>2024-12-28T11:52:49.807Z</td></tr><tr><td>MasterYoba</td><td><p>В настройках клиента надо ещё flow сделать пустым вместо rprx-vision (вдруг забыли). А так должно работать</p></td><td>2024-12-28T12:01:27.957Z</td></tr><tr><td>rewhat</td><td><p>Да, надо было flow пустым сделать, теперь работает, спасибо.</p></td><td>2024-12-28T12:06:13.021Z</td></tr><tr><td>1unknown(Unknown)</td><td><p>Это не демаскирует клиента для провайдера?</p></td><td>2024-12-28T12:07:33.051Z</td></tr><tr><td>sakontwist</td><td><p>Отключение flow xtls-rprx возвращает проблему tls-in-tls. Если транспорт xhttp ее не решает, то конечно демаскирует</p></td><td>2024-12-28T13:37:02.811Z</td></tr><tr><td>PlavaliZnaem( )</td><td><p>Предположу, что не демаскирует, так как в xhttp работает мультиплексирование. Т.е. клиент смешивает в кучу все сессии, потом нарезает в n-ое количество уже новых сессий и уже на сервере собирает в нужную последовательность. Таким образом с одной стороны уменьшается количество открытых сессий, а с другой стороны  это одновременно является идеальной маскировкой.<br>
Но это лишь мое предположение, сам хочу получить ответ, прав ли я.</p></td><td>2024-12-28T14:40:03.583Z</td></tr><tr><td>MasterYoba</td><td><p>Я изучил все китайские посты и статьи по теме (которых к слову не особо много, все ссылки есть в этом треде), и по сути единственное упоминание tls-in-tls в контексте xhttp вот это:</p>
<p>(<a href="https://github.com/XTLS/Xray-core/discussions/4113#discussioncomment-11468947" rel="noopener nofollow ugc">https://github.com/XTLS/Xray-core/discussions/4113#discussioncomment-11468947</a>)</p>
<blockquote>
<p><strong>И, наконец, кульминация - еще одна новая эра: разделение исходящего и входящего трафика.</strong> Мы знаем, что сейчас GFW обнаруживает такие характеристики трафика, как TLS in TLS, основываясь на одном соединении. <strong>Таким образом, если мы разделим исходящий и входящий трафик на разные системы проверки, например, исходящий трафик будет идти через IPv4 TCP, а входящий - через IPv6 UDP, GFW не сможет сразу среагировать.</strong></p>
</blockquote>
<p>Т.е. да, по всей видимости tls-in-tls там присутствует, как в классическом vless без rprx-vision, а бороться с детектом они предлагают через разделение потоков на up и down и мультиплекс сессий.  Видимо, xhttp изначально делался под использование именно с CDN на как миниум одном из потоков, а там rprx-vision всё равно применить никак нельзя. На всякий случай спросил у разработчиков ещё.</p>
<p>Собственно поэтому от идеи использовать xhttp с только прямым reality подключением я пока отказался. Сейчас удалось настроить более замороченные схемы по типу CDN_UP+REALITY_DOWN и CDN UP+DOWN через два разных домена, буду пока их тестировать.</p></td><td>2024-12-28T14:55:32.226Z</td></tr><tr><td>sakontwist</td><td><p>Мультиплексирование не решает tls-in-tls, да</p></td><td>2024-12-28T14:56:23.028Z</td></tr><tr><td>PlavaliZnaem( )</td><td><aside class="quote no-group" data-username="MasterYoba" data-post="31" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/masteryoba/48/6182_2.png" class="avatar"> MasterYoba:</div>
<blockquote>
<p>Сейчас удалось настроить более замороченные схемы по типу CDN_UP+REALITY_DOWN и CDN UP+DOWN через два разных домена, буду пока их тестировать.</p>
</blockquote>
</aside>
<p>Можно примеры конфигурации сервера и клиента?</p></td><td>2024-12-28T15:26:13.349Z</td></tr><tr><td>MasterYoba</td><td><p>Я все конфиги взял отсюда:</p><aside class="onebox allowlistedgeneric" data-onebox-src="https://github-com.translate.goog/XTLS/Xray-core/discussions/4118?_x_tr_sl=auto&amp;_x_tr_tl=en&amp;_x_tr_hl=en&amp;_x_tr_pto=wapp">
  <header class="source">
      <img src="https://ntc.party/uploads/default/original/2X/b/bad3e5f9ad67c1ddf145107ce7032ac1d7b22563.svg" class="site-icon" data-dominant-color="" width="32" height="32">

      <a href="https://github-com.translate.goog/XTLS/Xray-core/discussions/4118?_x_tr_sl=auto&amp;_x_tr_tl=en&amp;_x_tr_hl=en&amp;_x_tr_pto=wapp" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/344;"><img src="тестируем-xhttp/b6888f4fd946a014069f653d2c6a138a992a8218_2_690x345.png" class="thumbnail" data-dominant-color="E2E7E9" width="690" height="345"></div>

<h3><a href="https://github-com.translate.goog/XTLS/Xray-core/discussions/4118?_x_tr_sl=auto&amp;_x_tr_tl=en&amp;_x_tr_hl=en&amp;_x_tr_pto=wapp" target="_blank" rel="noopener nofollow ugc">xhttp 五合一配置 ( reality 直连与过 CDN 共存, 附小白可抄的配置) · XTLS/Xray-core · Discussion #4118</a></h3>

  <p>根据R佬的文章 #4113 ，写了 xhttp 五合一的配置，在同一台 VPS 的 443 端口实现了： XTLS(Vision)+Reality 直连 xhttp+Reality 直连 上行 xhttp+TLS+CDN | 下行 xhttp+Reality （上下行不同SNI） xhttp+TLS 过CDN 上行 xhttp+Reality | 下行 xhttp+TLS+CDN （上下行不...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Нужен nginx, да. В конфигурации клиентов раздел “sockopt” можно опускать, в блоке “extra” можно убрать всё кроме “downloadSettings”, если их нет - можно весь “extra” также опустить. (это написано там в комментах иероглифами, советую весь конфиг переводчиком с китайского тоже прогнать, чтобы комментарии были понятны)</p>
<p>Единственное, что я добавил от себя - конфиг клиента для cdn up/down на два домена:</p>
<pre><code class="lang-auto">      //xhttp_cdn_up_down
      {
        "tag": "proxy",
        "protocol": "vless",
        "settings": {
          "vnext": [
            {
              "address": "domain1.com",
              "port": 443,
              "users": [
                {
                  "id": "ваш_xhttp_id",
                  "encryption": "none"
                }
              ]
            }
          ]
        },
        "streamSettings": {
          "network": "xhttp",
          "security": "tls",
          "tlsSettings": {
            "serverName": "domain1.com",
            "allowInsecure": false,
            "alpn": ["h2"],
            "fingerprint": "chrome"
          },
          "xhttpSettings": {
            "host": "",
            "path": "/ваш_xhttp_path",
            "mode": "auto",
            "extra": {
              "downloadSettings": {
                "address": "domain2.com",
                "port": 443,
                "network": "xhttp",
                "security": "tls",
                "tlsSettings": {
                  "allowInsecure": false,
                  "alpn": ["h2"],
                  "fingerprint": "chrome"
                },
                "xhttpSettings": {
                  "host": "domain2.com",
                  "path": "/ваш_xhttp_path",
                  "mode": "auto"
                }
              }
            }
          }
        }
      },
</code></pre>
<p>Тут “восходящий” поток идёт через domain1, а “нисходящий” через domain2. Оба домена приземляются на nginx через cdn.</p></td><td>2024-12-28T16:18:08.984Z</td></tr><tr><td>PlavaliZnaem( )</td><td><p>И все-таки я продолжу предполагать, что xhttp закрывает проблему tls-in-tls, привел весь текст, но главное внизу выделил:</p>
<p>Try to understand the focus and logic of our series of protocols under XTLS. If you are wrong, please@RPRXCorrection.</p>
<p>The first generation of XTLS splice/direct/origin, etc. - solving performance:<br>
traditional TLS over TLS will have two layers of encryption overhead, while XTLS directly and losslessly embeds/splices the inner TLS data into the outer TLS stream, making the surface It’s still single-layer TLS, but the proxy traffic is actually hidden. Reduce repeated encryption and decryption processes. The CPU load and encryption and decryption costs are significantly reduced without sacrificing security, thus improving performance.</p>
<p>VISION----Solution to TLS in TLS characteristics:<br>
When multi-layer TLS is superimposed (TLS in TLS), there are two interactions between the inner TLS handshake and the outer TLS. This timing has obvious characteristics and can be accurately identified by GFW. The significance of VISION is to smooth out this unnatural timing characteristic by simulating delay and message exchange sequence, making the multi-layer TLS handshake process look closer to real Internet traffic and reducing the risk of being identified.</p>
<p>REALITY----Solving the SNI blocking problem:<br>
Mainland China’s SNI cannot be encrypted, so GFW can identify and block it through SNI.<br>
REALITY disguises itself in the TLS handshake and certificate delivery. By returning a certificate and initial data that looks like a real website in the handshake between the two parties, it is difficult to distinguish the authenticity of the entire TLS connection and the connection to the “big factory” HTTPS website. If GFW wants to block it, it needs to risk accidentally damaging the real website.</p>
<p>XHTTP - solves the common “single tunnel” feature of circumvention protocols:<br>
traditional protocols (such as Shadowsocks, Vmess, Trojan, etc.) usually only encrypt data and continuously transmit it through a specific port, which can appear to be “stable and long-lasting” “Time encrypted flow” characteristics; reviewers can suspect that it is proxy traffic through statistical analysis, long connection characteristics, and data transmission patterns.<br>
Therefore, XHTTP focuses on the application layer this time, further packaging the encrypted transmission into real HTTP requests and responses. By splitting the upstream data into multiple normal-looking POST requests and URLs with randomized parameters, the downstream data is disguised as large file streaming downloads or the continuous output of SSE (Server-Sent Events), which makes the traffic behavior different from that of ordinary users. The browsing and downloading patterns are very close. Compared with traditional “encrypted tunnels”, <strong>XHTTP is no longer a stable and continuous data pipeline, but is ostensibly composed of multiple independent, fragmented and natural HTTP interactions, more like common WEB access actions.</strong></p></td><td>2024-12-28T17:54:50.042Z</td></tr><tr><td>NowAndThen</td><td><p>А какой CDN используете, Cloudflare или что-то еще? И что настраиваете на стороне провайдера?</p></td><td>2024-12-28T17:56:06.526Z</td></tr><tr><td>lucretia(lucretia)</td><td><p>А может кто-нибудь пожалуйста привести конфиг для 3xui с xhttp для двух reality сайтов (без воровства своего серта)</p>
<p>Вроде такое возможно или нет?</p></td><td>2024-12-28T18:14:25.620Z</td></tr><tr><td>NowAndThen</td><td><ol>
<li>Создаете новый inbound.</li>
<li>Вводите порт 443, или другой, если этот у вас уже где-то занят.</li>
<li>Выбираете в выпадающем меню Transmission XHTTP</li>
<li>Выбираете Security Reality</li>
<li>Вводите в Dest и SNI воруемый сайт.</li>
<li>Получаете ключи кнопкой Get New Cert.</li>
<li>Жмете Create.</li>
<li>Экспортируете ключик в клиент.</li>
</ol></td><td>2024-12-28T18:29:20.812Z</td></tr><tr><td>PlavaliZnaem( )</td><td><aside class="quote no-group" data-username="NowAndThen" data-post="38" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/letter_avatar_proxy/v4/letter/n/c0e974/48.png" class="avatar"> NowAndThen:</div>
<blockquote>
<p>Экспортируете ключик в клиент.</p>
</blockquote>
</aside>
<p>Стоит уточнить, что клиентов, которые поддерживают xhttp можно пересчитать  по пальцам. На винду, по-моему, только v2rayN</p></td><td>2024-12-28T18:32:40.032Z</td></tr><tr><td>MasterYoba</td><td><p>Cloudflare. Настройки базовые, просто заведён домен купленный на godaddy, в разделе DNS records создана AAAA запись указывающая на ipv6 адрес сервера, включено проксирование, в настройках кеширования всё отключено, в настройках SSL/TLS режим Full (strict). Для второго домена то же самое. В конфиге nginx нужно разумеется оба домена указать, у обоих выполняется grpc_pass на xhttp сокет, как в тех конфигах у китайцев:</p>
<pre><code class="lang-auto">server {
    listen [ваш_ipv6_адрес]:443 ssl ipv6only=on http2 so_keepalive=on;

    server_name domain1.com;

    ssl_certificate /path/cloudflare_cert/domain1.com.pem;
    ssl_certificate_key /path/cloudflare/domain1.com.key;
    ...
}

server {
    listen [ваш_ipv6_адрес]:443 ssl ipv6only=on http2 so_keepalive=on;

    server_name domain2.com;

    ssl_certificate /path/cloudflare_cert/domain2.com.pem;
    ssl_certificate_key /path/cloudflare/domain2.com.key;
    ...
}
</code></pre>
<p>Сертификаты для nginx берутся в панели cloudflare в разделе SSL/TLS → Origin Server → Origin Certificates<br>
Можно обойтись и одним верхним доменом, использовать субдомены типа <a href="http://up.domain1.com" rel="noopener nofollow ugc">up.domain1.com</a> и <a href="http://down.domain1.com" rel="noopener nofollow ugc">down.domain1.com</a>, но целесообразность этого под вопросом.</p></td><td>2024-12-28T19:19:46.743Z</td></tr><tr><td>naykaminka(Sergey)</td><td><p>если не разделять трафик на 4 и 6 то получается палево ?</p></td><td>2024-12-28T19:48:54.033Z</td></tr><tr><td>NowAndThen</td><td><p><a class="mention" href="/u/masteryoba">@MasterYoba</a> А не затруднит пояснить за топологию этой схемы, пытаюсь понять, как это все работает. Вот есть клиент, который хочет сходить на экстремистский Твиттер. Обычно он идет на ваш прокси и там в туннеле сообщает вам, что хочет посетить Твиттер, наш прокси сервер ему его приносит в зашифрованном туннеле. А тут куда запрос клиента в вашем случае идет? На сервер Cloudflare  или на ваш UP домен? Куда дальше идет ответ с Твиттера, как он понимает, что нужно ответить на DOWN домен? И какую роль тут играет Cloudflare?</p></td><td>2024-12-28T21:54:54.662Z</td></tr><tr><td>MasterYoba</td><td><p>Нет, разницы никакой, этот ipv6 служит только для стыковки сервера с cloudflare и цензору он не виден. Можно всё повесить на один ipv4 адрес, именно так китайцы в конфигах выше и делают. У меня просто был дополнительно свободный ipv6 адрес, cloudflare с ними дружит, и я захотел сделать вот так.</p></td><td>2024-12-28T22:19:08.426Z</td></tr><tr><td>TikTak(TikTak)</td><td><blockquote>
<p>Минус пока в том, что все популярные клиенты на Sing-Box, а его авторы запрос на поддержку XHTTP дропнули и не известно, будут ли вообще его прикручивать. Поэтому нам остается только V2RayN.</p>
</blockquote>
<p>Так подождите, а V2RayN поддержку 32бит выпилили что ли. В 6 версии была же вроде</p></td><td>2024-12-28T22:41:26.820Z</td></tr><tr><td>MasterYoba</td><td><p>Всё то же самое, просто соединение с прокси сервером строится не напрямую, а через cloudflare. Клиент сначала строит “честное” tls соединение с сервером Cloudflare с SNI вашего купленного домена, а внутрь него заворачивает соединение с экстремистским твиттером посредством vless с выбранным транспортом через ваш VPS прокси-сервер. VPS сервер как бы спрятан за CDN как за щитом, внешний наблюдатель видит только обращение к ip-адресам CF и SNI вашего домена, но про сам VPS ничего не знает. Всё что может сделать цензор - забанить ваш домен, который легко сменить.</p>
<p>Вот тут очень хорошая статья по этой теме:</p><aside class="onebox allowlistedgeneric" data-onebox-src="https://miracleptr.wordpress.com/2023/09/18/%d0%be%d1%81%d0%be%d0%b1%d0%b5%d0%bd%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d0%bf%d1%80%d0%be%d0%ba%d1%81%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d1%87%d0%b5%d1%80%d0%b5%d0%b7-cdn-websocket-grpc/">
  <header class="source">
      <img src="тестируем-xhttp/7ad08aa585a29ef987d7472bbc27f661bcb308bd.jpeg" class="site-icon" data-dominant-color="E7E5DB" width="32" height="32">

      <a href="https://miracleptr.wordpress.com/2023/09/18/%d0%be%d1%81%d0%be%d0%b1%d0%b5%d0%bd%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d0%bf%d1%80%d0%be%d0%ba%d1%81%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d1%87%d0%b5%d1%80%d0%b5%d0%b7-cdn-websocket-grpc/" target="_blank" rel="noopener nofollow ugc" title="10:00AM - 18 September 2023">MiraclePtr – 18 Sep 23</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:440/246;"><img src="тестируем-xhttp/a03b067e76f1722cde8df4122a27fe102945d437.png" class="thumbnail" data-dominant-color="F8F8F8" width="440" height="246"></div>

<h3><a href="https://miracleptr.wordpress.com/2023/09/18/%d0%be%d1%81%d0%be%d0%b1%d0%b5%d0%bd%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d0%bf%d1%80%d0%be%d0%ba%d1%81%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d1%87%d0%b5%d1%80%d0%b5%d0%b7-cdn-websocket-grpc/" target="_blank" rel="noopener nofollow ugc">Особенности проксирования через CDN/Websocket/gRPC для обхода блокировок</a></h3>

  <p>В&nbsp;предыдущих публикациях я упоминал, что&nbsp;клиенты и серверы XRay (форк V2Ray) и Sing‑box при&nbsp;использовании протоколов VLESS/VMess/Trojan могут работать через веб‑сокеты и gRPC, что&nbsp;позволяет подключ…</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Из минусов тут только характеристика трафика tls-in-tls, как раз с которой вроде как и должен помогать транспорт xhttp. Теперь с ним запросы от клиента идут по одному “каналу” к CDN с внешним SNI domain1, а ответы от сервера по второму каналу с внешним SNI domain2. Насколько это эффективно - черт его знает, но выглядит перспективнее, чем “простое” проксирование через CDN с транспортом вебсокет или grpc.</p></td><td>2024-12-28T22:44:33.994Z</td></tr><tr><td>NowAndThen</td><td><p><a class="mention" href="/u/masteryoba">@MasterYoba</a> Я правильно понял, что эти ваши домены просто висят в воздухе, получается, зарегистрированы на CF и все, на них нет никаких сайтов? А Xray сервер у вас на третьем домене или на голом IP? Или как?</p></td><td>2024-12-28T23:36:30.262Z</td></tr><tr><td>MasterYoba</td><td><p>Домен зарегистрированный в CF указывает на IP-адрес vps сервера (v4 или v6 - без разницы), весь трафик к этому домену на 443 порт CF проксирует через себя, т.е. при DNS резолвинге отдаёт клиенту не IP-адрес сервера, а IP-адреса своих “промежуточных” серверов.</p>
<p>На vps сервере на 443 порту слушает nginx, а там уже можно хостить любой контент, и веб сайты в том числе. То есть можно сделать <a href="http://domain1.com/mywebsite" rel="noopener nofollow ugc">domain1.com/mywebsite</a> - ваша веб-страничка с котиками, <a href="http://domain1.com/proxy" rel="noopener nofollow ugc">domain1.com/proxy</a> - grpc_pass на сокет, где слушает xray. Вообще, чем об этом так рассуждать проще самому посмотреть и поиграться, цена вопроса - рублей 100 за какой-нибудь самый дешевый домен (главное не .ru/su/рф), а cloudflare бесплатен.</p></td><td>2024-12-29T08:50:04.430Z</td></tr><tr><td>wsvall</td><td><p>А как можно не указывать порт при создании inbound в панели 3x ?<br>
Я когда ввожу /dev/shm/xrxh.socket,0666 и выбираю порт 0, панель возвращает значение 1 вместо 0 )</p></td><td>2024-12-30T15:50:26.217Z</td></tr><tr><td>NowAndThen</td><td><p>Оставить как есть. В json файле конфигурации и в списке входящих соединений в панеле будет 0. Почему-то в настройках инбаунда он 1 показывает, недоработка UI.</p></td><td>2024-12-30T16:44:31.663Z</td></tr><tr><td>NowAndThen</td><td><p>Настроил раздельный XHTTP <a href="https://github-com.translate.goog/XTLS/Xray-core/discussions/4084?_x_tr_sl=auto&amp;_x_tr_tl=en&amp;_x_tr_hl=en&amp;_x_tr_pto=wapp" rel="noopener nofollow ugc">по китайским гайдам</a>. С одним доменом даже обошелся и через 3X-UI по большей части. Домен регистрируем в Cloudflare, у регистратора, где покупали прописываем кастомные DNS сервера, которые выдаст CF, включаем ему  gRPC (в СF кабинет настройки домена, закладка Network), <a href="https://ruvds.com/ru/helpcenter/kak-otkliuchit-ech/" rel="noopener nofollow ugc">отключаем ECH</a>, который запрещен в РФ.</p>
<p>На 3Х-UI сервере запускаем меню командой x-ui и выбираем там  Cloudflare SSL Certificate. Нужно ввести свой имейл аккаунта CF, Global API Key (настройки домена в CF кабинете, вкладка Overview, внизу справа) и имя домена. Он создаст автоматом родной сертификат CloudFlare на 15 лет и импортирует его в панель. В вкладке SSL/TLS Encryption для домена в кабинете CF выбираем режим Full (Strict). Теперь вход только по CF сертификату.</p>
<p>В панеле 3Х-UI создаем новый инбаунд. Назовем, чтобы не запутаться Remark: Vision-Reality. Порт 443. Дальше именно щас важно в Fallback в поле Dest вписать порт 2023, на котором нас будет слушать следующий инбаунд. Transmission TCP. Дальше выбираем Security: Reality. Fallback исчезает, не пугайтесь, его настройки в JSON конфиге сохранятся. В Dest (Target) прописываем порт 7443, на котором будет слушать Nginx. Xver = 1, общаются они через Proxy Protocol. В SNI указываем наш <a href="http://cdn-domain.com" rel="noopener nofollow ugc">cdn-domain.com</a>. Возвращаемся в раздел Client и ставим Flow: xtls-rprx-vision. Возвращаемся в настройки Reality. Генерируем ключи. Жмем Create. Готово.</p>
<p>Создаем второй инбаунд. Remark: XHTTP. Listen 127.0.0.1. Port 2023. Transmission: XHTTP. Path: xhttp-path (такой же как в конфиге Nginx). Security: TLS.  SNI: <a href="http://cdn-domain.com" rel="noopener nofollow ugc">cdn-domain.com</a> - ваш домен. Жмем Set Cert from Panel, он подставит сгенерированные ранее сертификаты CloudFlare. Create. Готово.</p>
<p>Код для сервера Nginx.</p>
<pre><code class="lang-auto">server {

	root /var/www/html;
	index index.html index.htm index.nginx-debian.html;

	server_name cdn-domain.com www.cdn-domain.com; // Укажите свой домен на CloudFlare

	location / {
		try_files $uri $uri/ =404;
	}

	listen 127.0.0.1:7443 ssl http2 proxy_protocol;
	set_real_ip_from 127.0.0.1;
	real_ip_header proxy_protocol;

	ssl_certificate /root/cert-CF/cdn-domain.com/fullchain.pem; // Путь к сертификатам CloudFlare
	ssl_certificate_key /root/cert-CF/cdn-domain.com/privkey.pem; // Путь к сертификатам CloudFlare

	location /xhttp-path {
		proxy_http_version 1.1;
		proxy_pass http://127.0.0.1:2023;
		proxy_redirect off;
		proxy_request_buffering off;
		proxy_set_header Host $host;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	}
}

server {
    listen 80;
    listen [::]:80;
    server_name cdn-domain.com www.cdn-domain.com; // Укажите свой домен на CloudFlare
    return 302 https://$server_name$request_uri;
}
</code></pre>
<p>Дальше нужно клиентскую часть загнать в V2RayN (единственный на сегодня клиент, который умеет в XHTTP). Здесь придется поколдовать руками, два наших соединения надо сшить в одного хитрого Франкенштейна. Экспортируем ключик от Vision-Reality в V2RayN. Он как есть работать не будет! Экспортируем его оттуда в буфер и допиливаем секцию “outbounds” в блокноте. Если у вас нет второго, “прямого” домена, вместо <a href="http://direct-domain.com" rel="noopener nofollow ugc">direct-domain.com</a> просто вбиваем IP вашего Xray сервера.</p>
<pre><code class="lang-auto">  "outbounds": [
    {
      "tag": "proxy",
      "protocol": "vless",
      "settings": {
        "vnext": [
          {
            "address": "cdn-domain.com", // Ваш домен CloudFlare
            "port": 443,
            "users": [
              {
                "id": "6cc4e521-e0db-4c7d-a4c6-453f5d8c64e8", // поменять на ID инбаунда XHTTP
                "email": "t@t.tt",
                "security": "auto",
                "encryption": "none",
                "flow": "xtls-rprx-vision"
              }
            ]
          }
        ]
      },
      "streamSettings": {
        "network": "xhttp", //поменять на "xhttp"

        // добавить объект "xhttpSettings"

        "xhttpSettings": {
          "mode": "auto",
          "path": "/xhttp-path", // Path из инбаунда XHTTP
          "extra": {
            "downloadSettings": {
              "address": "direct-domain.com", // прямой домен или IP Xray сервера
              "port": 443,
              "network": "xhttp",
              "xhttpSettings": {
                "mode": "auto",
                "path": "/xhttp-path" // Path из инбаунда XHTTP
              }
            }
          }
        },

        "security": "reality",
        "realitySettings": {
          "serverName": "direct-domain.com", // меняем на прямой домен или IP Xray сервера
          "fingerprint": "chrome",
          "show": false,
          "publicKey": "ob_ZLNraBpBrEi5YuedCt_eg69IfXWBWANy86-lVKg0", // Публичный ключ инбаунда Vision-Reality, оставить как есть
          "shortId": "4ef078", // Short ID инбаунда Vision-Reality, оставить как есть
          "spiderX": "/"
        }
      },
      "mux": {
        "enabled": false,
        "concurrency": -1
      }
    }
</code></pre>
<p>Импортируем снова в V2RayN. Запускаем, работаем!</p>
<p>Плюсы. Гиперпаранойность. Все запросы идут в восходящем потоке через CloudFlare, цензор не видит IP вашего VPS, вы обращаетесь к IP CDN. Нисходящий поток идет к вам с VPS, тут его IP видно, но связать домен с IP цензор не может. Детектировать такую схему намного сложнее.</p>
<p>Минусы. Сложность в настройке. Вырастут задержки из-за того, что у нас еще CDN появляется в цепочке. Также из-за того, что XHTTP шинкует трафик, снижается полезная полоса, т.е. несколько снизится скорость загрузок.</p></td><td>2025-01-01T12:32:09.690Z</td></tr><tr><td>1unknown(Unknown)</td><td><p>Гипотетически, если использовать VLESS+TLS со своим доменом с Ngnix на 80 и 443 порту для сайта-заглушки, то пока нет смысла прятать IP VPS?</p></td><td>2025-01-01T16:16:17.413Z</td></tr><tr><td>NowAndThen</td><td><p>Пока все работает. Это сильно паранойный сценарий на гипотетическое северокорейское будущее. Но и тут прибегут другие параноики, которые скажут, да этот ваш CloudFlare забанят к чертям. Нельзя исключать и такие варианты. Но как по мне, тут уже не настройки надо будет искать, а чемодан паковать.</p></td><td>2025-01-01T19:20:50.027Z</td></tr><tr><td>naykaminka(Sergey)</td><td><aside class="quote no-group" data-username="NowAndThen" data-post="50" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/letter_avatar_proxy/v4/letter/n/c0e974/48.png" class="avatar"> NowAndThen:</div>
<blockquote>
<p>но связать домен с IP цензор не может.</p>
</blockquote>
</aside>
<p>По какой причине не сможет ?<br>
Сама сеть выглядит подозрительно когда исходящие запросы идут в цдн и тут же возвращаются с какого-то непонятного айпишника, который на проверку окажется ещё и в пуле хост провайдера, тут же очевидно наш прокси хитрюля спрятался.<br>
Не понятны такие телодвиженя, они рассчитаны на то что роскомнадзор будет честно себя вести ?</p></td><td>2025-01-01T19:42:28.176Z</td></tr><tr><td>NowAndThen</td><td><aside class="quote no-group" data-username="naykaminka" data-post="53" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/naykaminka/48/13848_2.png" class="avatar"> naykaminka:</div>
<blockquote>
<p>Сама сеть выглядит подозрительно когда исходящие запросы идут в цдн и тут же возвращаются с какого-то непонятного айпишника, который на проверку окажется ещё и в пуле хост провайдера, тут же очевидно наш прокси хитрюля спрятался.</p>
</blockquote>
</aside>
<p>Тут как раз все безобидно выглядит. Я отправляю какие-то запросы на CDN, т.е. как будто члены семьи посещают какие-то сайты с котиками, за этим CDN сидящие. А параллельно с одного IP качаю файло, например, и на этом IP легальный файлообменник к тому же. Как цензор может это вскрыть и увязать, что это одна сессия? Как от свяжет моит параллельные запросы к эсктремисткому фейсбуку и к легальному новостному сайту, сидящими за одним CDN? Никак. За CDN он не видит, куда я хожу. На этом CDN и строят свою безопасность. На этом и китайский трюк строится. Как раз когда вы сидите постоянно в одном туннеле, этот трафик, хотя и тоже нельзя вскрыть, и посмотреть куда вы идете, но его можно хотя бы статистически анализировать. А тут что с чем коррелирует? Как это по пакетам вынюхивать? Тут головоломка на порядок сложнее.</p></td><td>2025-01-01T20:05:41.641Z</td></tr><tr><td>0ka(0ka)</td><td><aside class="quote no-group" data-username="naykaminka" data-post="53" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/naykaminka/48/13848_2.png" class="avatar"> naykaminka:</div>
<blockquote>
<p>запросы идут в цдн</p>
</blockquote>
</aside>
<p>и возвращаются оттуда же…</p></td><td>2025-01-02T08:10:15.983Z</td></tr><tr><td>naykaminka(Sergey)</td><td><p><a href="https://ntc.party/u/NowAndThen">NowAndThen</a> выше пишет что не оттуда, кто из вас прав ?<br>
Мне казалось что в этом и смысл возни с Xhhtp - гонять трафик через цднку и маскировать айпи своего сервера.</p></td><td>2025-01-02T10:08:49.076Z</td></tr><tr><td>0ka(0ka)</td><td><aside class="quote no-group" data-username="naykaminka" data-post="56" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/naykaminka/48/13848_2.png" class="avatar"> naykaminka:</div>
<blockquote>
<p>выше пишет что не оттуда</p>
</blockquote>
</aside>
<p>цитата? я ничего не понял</p></td><td>2025-01-02T10:15:07.765Z</td></tr><tr><td>NowAndThen</td><td><p>Еще глюк обнаружился у этого сетапа. Хитрый юзерский ручной конфиг не стартует у меня при запуске V2RayN, нужно сначала выбрать какой-то другой конфиг, а потом переключиться на этот раздельный XHTTP. Т.е. в автозагрузке он не работает. И на Андроиде в V2RayNG запустить этот конфиг вообще не удалось. Вобщем, юзабельность этой технологии пока сильно в бета стадии.</p></td><td>2025-01-03T18:09:34.844Z</td></tr><tr><td>4nonch(4nonch)</td><td><p>Приветствую. Извиняюсь если подобный вопрос был, я не нашёл ответов.</p>
<p>Ловлю следующую ошибку:<br>
<code>[Info] transport/internet/splithttp: invalid x_padding length:0</code></p>
<p>Версии софта:</p>
<ul>
<li><code>nginx/1.26.2</code></li>
<li><code>Xray 24.12.31</code></li>
</ul>
<p>Кто-нибудь сталкивался с подобным? Ниже приведу свои конфигурации nginx’а и xray’я как для сервера, так и для клиента.</p>
<p>На всякий случай сообщу что использую path поверх уже существующей конфигурации nginx’а под приложение. Однако, хочу заверить что схема с vless-nginx через websocket работала и работает, проблемы возникли при пробе XHTTP.</p>
<p>Некоторые переменные заменил, даю им здесь определение:</p>
<ul>
<li><code>myhost</code> - алиас сервера, не особо важно, просто строка для всяких директорий</li>
<li><code>my.host.com</code> - домен для доступа к серверу через HTTP (ex: <a href="https://my.host.com/" rel="noopener nofollow ugc">https://my.host.com/</a>)</li>
<li><code>mypath</code> - путь в nginx’е перенаправляющий на <code>xray</code> инстанс</li>
<li><code>myuuid</code> - мой uuid</li>
</ul>
<p>Конфигурация <code>nginx</code>:</p>
<pre data-code-wrap="nginx"><code class="lang-nginx">upstream myhost {
    server unix:/srv/.venvs/myhost/run/gunicorn.sock fail_timeout=0;
}

server {
    server_name my.host.com;
    listen 80;
    return 301 https://my.host.com$request_uri;
}

server {
    server_name my.host.com;
    listen 443 ssl;
    listen 443 quic reuseport ipv6only=off;

    ssl_protocols TLSv1.3 TLSv1.2;
    ssl_certificate /etc/letsencrypt/live/my.host.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/my.host.com/privkey.pem;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GC    M-SHA384;

    client_header_timeout 5m;
    keepalive_timeout 5m;

    client_max_body_size 15M;

    access_log /var/log/myhost/nginx/access/access.log;
    error_log /var/log/myhost/nginx/error/error.log;

    location /mypath {
        client_max_body_size 0;
        grpc_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        client_body_timeout 5m;
        grpc_read_timeout 315;
        grpc_send_timeout 5m;
        grpc_pass unix:/dev/shm/xrxh.socket;
    }

    location /static/ {
        alias /srv/myhost/static/;
    }

    location / {
        proxy_pass http://myhost/;
        proxy_http_version 1.1;

        proxy_connect_timeout 1;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
</code></pre>
<p>Конфигурация для <code>xray server</code>:</p>
<pre data-code-wrap="json"><code class="lang-json">{
    "log": {
        "loglevel": "debug",
        "access": "/var/log/xray/access.log",
        "error": "/var/log/xray/error.log",
        "dnsLog": false
    },
    "inbounds": [
        {
            "listen": "/dev/shm/xrxh.socket,0666",
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "id": "myuuid"
                    }
                ],
                "decryption": "none"
            },
            "streamSettings": {
                "network": "xhttp",
                "xhttpSettings": {
                    "mode": "stream-up",
                    "path": "/mypath"
                }
            }
        }
    ],
    "outbounds": [
        {
            "tag": "direct",
            "protocol": "freedom",
            "settings": {}
        },
        {
            "tag": "blocked",
            "protocol": "blackhole",
            "settings": {}
        }
    ],
    "routing": {
        "domainStrategy": "AsIs",
        "rules": [
            {
                "type": "field",
                "ip": [
                    "geoip:private"
                ],
                "outboundTag": "blocked"
            },
            {
                "type": "field",
                "domain": ["geosite:category-ads-all"],
                "outboundTag": "block"
            }
        ]
    }
}
</code></pre>
<p>Конфигурация для <code>xray client</code>:</p>
<pre data-code-wrap="json"><code class="lang-json">{
    "log": {},
    "inbounds": [
        {
            "port": "1080",
            "listen": "127.0.0.1",
            "protocol": "socks",
            "settings": {
                "udp": true
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "vless",
            "settings": {
                "vnext": [
                    {
                        "address": "my.host.com",
                        "port": 443,
                        "users": [
                            {
                                "id": "myuuid",
                                "encryption": "none"
                            }
                        ]
                    }
                ]
            },
            "streamSettings": {
                "network": "xhttp",
                "xhttpSettings": {
                    "path": "/mypath",
                    "mode": "stream-up",
                    "#xmux": {
                        "maxConcurrency": 128,
                        "hMaxRequestTimes": 1000,
                        "hMaxReusableSecs": 3600
                    },
                    "#downloadSettings": {
                        "address": "my.host.com",
                        "port": 443,
                        "network": "xhttp",
                        "xhttpSettings": {
                            "path": "/mypath",
                            "#xmux": {
                                "maxConcurrency": 128,
                                "hMaxRequestTimes": 1000,
                                "hMaxReusableSecs": 3600
                            }
                        },
                        "security": "tls"
                    }
                },
                "security": "tls",
                "tlsSettings": {
                    "alpn": [
                        "h3"
                    ]
                }
            }
        },
        {
            "tag": "direct",
            "protocol": "freedom",
            "settings": {}
        },
        {
            "tag": "blocked",
            "protocol": "blackhole",
            "settings": {}
        }
    ],
    "routing": {
        "domainStrategy": "IPOnDemand",
        "rules": [
            {
                "type": "field",
                "ip": [
                    "geoip:private"
                ],
                "outboundTag": "direct"
            }
        ]
    }
}
</code></pre></td><td>2025-01-03T21:05:07.673Z</td></tr><tr><td>NowAndThen</td><td><aside class="quote no-group" data-username="4nonch" data-post="59" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/4nonch/48/14681_2.png" class="avatar"> 4nonch:</div>
<blockquote>
<p>Ловлю следующую ошибку:<br>
<code>[Info] transport/internet/splithttp: invalid x_padding length:0</code></p>
</blockquote>
</aside>
<p>Попробуйте в xhttpSettings добавить такие параметры, это панель 3X-UI ставит по умолчанию, там, я смотрел, автор тупо рекомендуемые параметры из документации по умолчанию подставляет.</p>
<pre><code class="lang-auto">          "scMaxBufferedPosts": 30,
          "scMaxEachPostBytes": "1000000",
          "xPaddingBytes": "100-1000"
</code></pre></td><td>2025-01-03T22:16:17.050Z</td></tr><tr><td>4nonch(4nonch)</td><td><p>Спасибо за ответ и приношу извинения за глупый вопрос, оказывается <code>invalid x_padding length:0</code> не актуальная ошибка.</p>
<p>С моего клиента не приходили запросы на мой сервер, я решил попробовать пингануть <code>path</code> через curl, а в дальнейшем принял логи с curl’а как за те, что пришли с клиента. Спутал их. Очевидно что с курла будет ошибка авторизации и вообще там не был отправлен padding.</p>
<p>Настоящая проблема в том что запросы с клиента не доходят по какой-то причине, по всей видимости слишком криворукая конфигурация клиента/nginx’а. Попробую потом как-то решить.</p>
<pre><code class="lang-auto">2025/01/04 01:37:17 [Debug] [2049168422] transport/internet: dialing to udp:my.host.com:443
2025/01/04 01:37:17 [Info] [2049168422] transport/internet/splithttp: failed to POST https://my.host.com/mypath/7300f7be-ced5-411d-b209-ba16096ac392?x_padding=000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 &gt; Post "https://my.host.com/mypath/7300f7be-ced5-411d-b209-ba16096ac392?x_padding=000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": lookup my.host.com: no such host
2025/01/04 01:37:17 [Info] [2049168422] proxy/vless/outbound: tunneling request to tcp:130.255.77.28:443 via my.host.com:443
2025/01/04 01:37:18 [Info] [2049168422] app/proxyman/inbound: connection ends &gt; proxy/socks: connection ends &gt; context canceled
2025/01/04 01:37:18 [Info] [1788824348] proxy/socks: TCP Connect request to tcp:130.255.77.28:443
2025/01/04 01:37:18 [Info] [1788824348] app/dispatcher: default route for tcp:130.255.77.28:443
2025/01/04 01:37:18 [Info] [1788824348] transport/internet/splithttp: XHTTP is dialing to udp:my.host.com:443, mode stream-up, HTTP version 3, host my.host.com
2025/01/04 01:37:18 [Debug] [1788824348] transport/internet: dialing to udp:my.host.com:443
2025/01/04 01:37:18 from tcp:127.0.0.1:65297 accepted tcp:130.255.77.28:443
2025/01/04 01:37:18 [Info] [1788824348] transport/internet/splithttp: failed to GET https://my.host.com/mypath/c6edd6a5-bf19-4a60-9c8a-681ea555b57e?x_padding=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 &gt; Get "https://my.host.com/mypath/c6edd6a5-bf19-4a60-9c8a-681ea555b57e?x_padding=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": lookup my.host.com: no such host
2025/01/04 01:37:18 [Debug] [1788824348] transport/internet: dialing to udp:my.host.com:443
2025/01/04 01:37:18 [Info] [1788824348] transport/internet/splithttp: failed to POST https://my.host.com/mypath/c6edd6a5-bf19-4a60-9c8a-681ea555b57e?x_padding=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 &gt; Post "https://my.host.com/mypath/c6edd6a5-bf19-4a60-9c8a-681ea555b57e?x_padding=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": lookup my.host.com: no such host
2025/01/04 01:37:18 [Info] [1788824348] proxy/vless/outbound: tunneling request to tcp:130.255.77.28:443 via my.host.com:443
2025/01/04 01:37:19 [Info] [1788824348] app/proxyman/inbound: connection ends &gt; proxy/socks: connection ends &gt; context canceled
2025/01/04 01:37:22 [Debug] app/log: Logger closing
</code></pre></td><td>2025-01-03T22:51:25.363Z</td></tr><tr><td>4nonch(4nonch)</td><td><p>Оказывается это была опечатка хоста. Но теперь по какой-то причине падает <code>timeout: no recent network activity</code>.</p>
<p>На сервере всё ещё никаких логов у xray’я или nginx’а. Надо будет разобраться.</p>
<pre><code class="lang-auto">2025/01/04 02:09:43 [Info] [2279113200] transport/internet/splithttp: XHTTP is dialing to udp:my.host.com:443, mode stream-up, HTTP version 3, host my.host.com
2025/01/04 02:09:43 from tcp:127.0.0.1:57906 accepted tcp:130.255.77.28:443
2025/01/04 02:09:47 [Info] [2279113200] transport/internet/splithttp: failed to GET https://my.host.com/xxx/d147a73b-cc81-4498-9681-c66d03d2bcb9?x_padding=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 &gt; Get "https://my.host.com/mypath/d147a73b-cc81-4498-9681-c66d03d2bcb9?x_padding=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": timeout: no recent network activity
2025/01/04 02:09:47 [Info] [4142068304] transport/internet/splithttp: failed to POST https://my.host.com/xxx/3533c363-8add-4ab0-9e03-7bc8a8593d5f?x_padding=0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 &gt; Post "https://my.host.com/mypath/3533c363-8add-4ab0-9e03-7bc8a8593d5f?x_padding=0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": timeout: no recent network activity
2025/01/04 02:09:47 [Info] [4142068304] proxy/vless/outbound: tunneling request to tcp:142.250.65.164:443 via my.host.com:443
2025/01/04 02:09:47 [Debug] [2279113200] transport/internet: dialing to udp:my.host.com:443
2025/01/04 02:09:48 [Info] [4142068304] app/proxyman/inbound: connection ends &gt; proxy/socks: connection ends &gt; context canceled
2025/01/04 02:09:48 [Info] [1739706259] proxy/socks: TCP Connect request to tcp:142.250.65.164:443
2025/01/04 02:09:48 [Info] [1739706259] app/dispatcher: default route for tcp:142.250.65.164:443
2025/01/04 02:09:48 [Info] [1739706259] transport/internet/splithttp: XHTTP is dialing to udp:my.host.com:443, mode stream-up, HTTP version 3, host my.host.com
2025/01/04 02:09:48 from tcp:127.0.0.1:57907 accepted tcp:142.250.65.164:443
2025/01/04 02:09:52 [Info] [2279113200] transport/internet/splithttp: failed to POST https://my.host.com/xxx/d147a73b-cc81-4498-9681-c66d03d2bcb9?x_padding=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 &gt; Post "https://my.host.com/mypath/d147a73b-cc81-4498-9681-c66d03d2bcb9?x_padding=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": timeout: no recent network activity
2025/01/04 02:09:52 [Info] [1739706259] transport/internet/splithttp: failed to GET https://my.host.com/xxx/54c2b095-676f-4994-b4d8-54a5d2fca83e?x_padding=0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 &gt; Get "https://my.host.com/mypath/54c2b095-676f-4994-b4d8-54a5d2fca83e?x_padding=0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": timeout: no recent network activity
2025/01/04 02:09:52 [Info] [2279113200] proxy/vless/outbound: tunneling request to tcp:130.255.77.28:443 via my.host.com:443
2025/01/04 02:09:52 [Debug] [1739706259] transport/internet: dialing to udp:my.host.com:443
2025/01/04 02:09:53 [Info] [2279113200] app/proxyman/inbound: connection ends &gt; proxy/socks: connection ends &gt; context canceled
2025/01/04 02:09:53 [Info] [883022489] proxy/socks: TCP Connect request to tcp:130.255.77.28:443
2025/01/04 02:09:53 [Info] [883022489] app/dispatcher: default route for tcp:130.255.77.28:443
2025/01/04 02:09:53 [Info] [883022489] transport/internet/splithttp: XHTTP is dialing to udp:my.host.com:443, mode stream-up, HTTP version 3, host my.host.com
2025/01/04 02:09:53 from tcp:127.0.0.1:57910 accepted tcp:130.255.77.28:443
2025/01/04 02:09:56 [Debug] app/log: Logger closing
</code></pre></td><td>2025-01-03T23:25:19.583Z</td></tr><tr><td>Dude.rms</td><td><p>Подскажите, что вводить в хост и путь?<br>
И кто-то сравнивал скорость и задержку между tcp и xhttp?<br>
<div class="lightbox-wrapper"><a class="lightbox" href="тестируем-xhttp/7e8df4177af55a7e3ea0d32e9b373654e1c4b764.png" data-download-href="https://ntc.party/uploads/default/7e8df4177af55a7e3ea0d32e9b373654e1c4b764" title="21321"><img src="тестируем-xhttp/7e8df4177af55a7e3ea0d32e9b373654e1c4b764_2_412x500.png" alt="21321" data-base62-sha1="i3yiiNfD0oIZBQ9o0Bi9VmEshLu" width="412" height="500" srcset="тестируем-xhttp/7e8df4177af55a7e3ea0d32e9b373654e1c4b764_2_412x500.png, тестируем-xhttp/7e8df4177af55a7e3ea0d32e9b373654e1c4b764.png 1.5x, тестируем-xhttp/7e8df4177af55a7e3ea0d32e9b373654e1c4b764.png 2x" data-dominant-color="181B1D"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg><span class="filename">21321</span><span class="informations">469×568 20.2 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use href="#discourse-expand"></use></svg></div></a></div></p></td><td>2025-01-05T09:24:12.580Z</td></tr><tr><td>1unknown(Unknown)</td><td><p>Отвечу немного не по теме:<br>
Под <a href="http://vk.com" rel="noopener nofollow ugc">vk.com</a> не стоит маскироваться, если у вас зарубежный сервер. Если российский, то наверное ещё можно.</p></td><td>2025-01-05T10:09:00.318Z</td></tr><tr><td>NowAndThen</td><td><p>Host и Path по умолчанию пустые. Это для сложных ветвистых конфигураций, которые с nginx работают, чтобы обращаться к серверу по адресу <a href="http://myhost.com/mypath" rel="noopener nofollow ugc">myhost.com/mypath</a>.</p></td><td>2025-01-05T13:39:00.426Z</td></tr><tr><td>Dude.rms</td><td><p>У меня vk в моей подсети есть.</p></td><td>2025-01-05T14:58:53.925Z</td></tr><tr><td>1unknown(Unknown)</td><td><p>Учитывайте, что при анализе подсети, показывает ровно то, что прописали арендаторы. То есть, вероятно это другой человек решил маскироваться под vk, а не их настоящий сервер.<br>
Поэтому, например, из-за стандартных настроек в 3X-UI с маскировкой под <a href="http://yahoo.com" rel="noopener nofollow ugc">yahoo.com</a> - чаще всего встречается именно он) Но не всегда, конечно. Не стоит маскироваться под российский сайт, если сервер зарубежный. Это рекомендация не мной придумана, но в ней есть логика так как при обращении из РФ к российскому сайту идёт запрос к ближайшему серверу, а они находятся в РФ.<br>
Поэтому под российские сайты можно маскироваться только если арендуете сервер в РФ.</p></td><td>2025-01-05T15:44:26.182Z</td></tr><tr><td>Dude.rms</td><td><p>Благодарю. Действительно кто-то маскировался под vk.</p></td><td>2025-01-06T02:16:17.666Z</td></tr><tr><td>wsvall</td><td><p>А как можно проверить, что мультиплексинг работает?<br>
Читал, что с работающим мульт. должно быть меньше сессий, но как их вывести для глаз?<br>
В случае с XHTTP рекомендуют отключить <code>mux.cool</code><br>
В v2rayN mux.cool == Turn on Mux Multiplexing ?<br>
И какой лучше выбрать параметр в настройке sing-box Mux Protocol</p>
<details>
<summary>
картинка</summary>
<p><div class="lightbox-wrapper"><a class="lightbox" href="тестируем-xhttp/70e22553601cb1b09ff320d6297ccb0b4ed05f1d.png" data-download-href="https://ntc.party/uploads/default/70e22553601cb1b09ff320d6297ccb0b4ed05f1d" title="image"><img src="тестируем-xhttp/70e22553601cb1b09ff320d6297ccb0b4ed05f1d.png" alt="image" data-base62-sha1="g6BZuD9Ph5bfnDEx9DRDrzxLstL" width="419" height="500" data-dominant-color="E1E8E3"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg><span class="filename">image</span><span class="informations">508×606 16.2 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use href="#discourse-expand"></use></svg></div></a></div></p>
</details>
<p>Мультиплексинг может работает в режимах system proxy и TUN ?</p></td><td>2025-01-06T17:34:06.410Z</td></tr><tr><td>0ka(0ka)</td><td><p>В проге system informer вкладка network, там видно количество соединений. Singbox mux protocol не относится к xhttp, это встроенный mux в синге (работает с любым протоколом)</p></td><td>2025-01-06T17:54:10.656Z</td></tr><tr><td>Nocturnal-ru(Roman)</td><td><p>Singbox не поддерживает xhttp  и такой поддержки вроде как не будет, это во первых. А во вторых мультиплексирование будет работать только когда и клиент и сервер xray, насколько помню</p></td><td>2025-01-06T18:07:51.642Z</td></tr><tr><td>naykaminka(Sergey)</td><td><p>Тут только ручками считать ?<br>
<div class="lightbox-wrapper"><a class="lightbox" href="тестируем-xhttp/0455941a2ee397ced5dd7dd8efd0a440996f74af.png" data-download-href="https://ntc.party/uploads/default/0455941a2ee397ced5dd7dd8efd0a440996f74af" title="123"><img src="тестируем-xhttp/0455941a2ee397ced5dd7dd8efd0a440996f74af_2_689x416.png" alt="123" data-base62-sha1="ClgbnyP5DgDlwlQJWc2961Ak3R" width="689" height="416" srcset="тестируем-xhttp/0455941a2ee397ced5dd7dd8efd0a440996f74af_2_689x416.png, тестируем-xhttp/0455941a2ee397ced5dd7dd8efd0a440996f74af_2_1033x624.png 1.5x, тестируем-xhttp/0455941a2ee397ced5dd7dd8efd0a440996f74af.png 2x" data-dominant-color="F6F6F6"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg><span class="filename">123</span><span class="informations">1195×721 58.2 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use href="#discourse-expand"></use></svg></div></a></div></p>
<p>Помню был более удобный способ подсчитать колчиество соединений но я благополучно потерял вкладку со ссылкой.</p></td><td>2025-01-06T19:41:01.065Z</td></tr><tr><td>0ka(0ka)</td><td><p>В поиске надо ввести sing-box, локальные соединения считать нет смысла. На сервере можно это сделать тоже через ss или netstat. Ну и я типа не вижу смысла их считать, их либо 1 либо множество, варианты между не нужны</p></td><td>2025-01-07T04:06:09.579Z</td></tr><tr><td>hzdmnl(Hzdmnl)</td><td><p>Всем привет.<br>
У меня переход на xhttp прошел успешно.<br>
Поставил самый  свежий xray на сервер и на клиент. Обновил v2rayNG на Android телефоне.<br>
Вот мой рабочий конфиг на xray сервере:</p>
<pre><code class="lang-auto">  "inbounds": [
    {
      "listen": "0.0.0.0",
      "port": 443,
      "protocol": "vless",
      "tag": "reality-in",
      "settings": {
        "clients": [
          {
            "id": "ваш_ID",
            "email": "email"
          }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "xhttp",
        "xhttpSettings": {
          "host": "несуществущюий_сайт.com",
          "path": "/здесь-несуществующий_путь_на_этом_сайте",
          "read_idle_timeout": 10,
          "health_check_timeout": 15,
          "method": "GET"
        },
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "известный_существующий_сайт:443",
          "xver": 0,
          "serverNames": [
            "известный_существующий_сайт:443"
          ],
          "privateKey": "ваш_приватный_ключ",
          "minClientVer": "",
          "maxClientVer": "",
          "maxTimeDiff": 0,
          "shortIds": [""]
        }
      },
      "sniffing": {
        "enabled": true,
        "destOverride": [
          "http",
          "tls",
          "quic"
        ]
      }
    },
</code></pre>
<p>Поменял только “network”: “http” на “network”: “xhttp”. И “httpSettings”: на “xhttpSettings”:</p>
<hr>
<p>Вот рабочий конфиг xray клиента:</p>
<pre><code class="lang-auto">
 "outbounds": [

        {
            "protocol": "vless",
            "settings": {
                "vnext": [
                    {
                        "address": "адрес_вашего_xray_сервера", 
                        "port": 443, 
                        "users": [
                            {
                                "id": "ваш_ID", 
                                "encryption": "none"
                            }
                        ]
                    }
                ]
            },
        
      "streamSettings": {
        "network": "xhttp",
        "xhttpSettings": {
          "host": "несуществущюий_сайт.com",
          "path": "/здесь-несуществующий_путь_на_этом_сайте",
          "method": "GET"
        },
        "security": "reality",

                "realitySettings": {
                    "fingerprint": "chrome", 
                    "serverName": "известный_существующий_сайт",
                    "publicKey": "ваш_публичный_ключ",
                    "spiderX": "",
                    "shortId": "" 
                }      
             },

            "tag": "vless-server"
        },    
</code></pre>
<p>Поменял только “network”: “http” на “network”: “xhttp”. И “httpSettings”: на “xhttpSettings”:</p>
<p>Ссылка, которая работает в v2rayNG</p>
<pre><code class="lang-auto">vless://ваш_публичный_ключ@адрес_вашего_xray_сервера:443?mode=auto&amp;path=%2здесь-несуществующий_путь_на_этом_сайте&amp;security=reality&amp;alpn=h2&amp;encryption=none&amp;pbk=ваш_публичный_ключ&amp;host=несуществущюий_сайт.com&amp;fp=chrome&amp;type=xhttp&amp;sni=известный_существующий_сайт#
</code></pre>
<p>Что изменил в настройка - вместо “Сеть h2” - поставил “Сеть xhttp, Режим XHTTP auto”.</p></td><td>2025-01-07T11:10:08.652Z</td></tr><tr><td>wsvall</td><td><aside class="quote no-group" data-username="Nocturnal-ru" data-post="71" data-topic="13855" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/nocturnal-ru/48/1556_2.png" class="avatar"> Nocturnal-ru:</div>
<blockquote>
<p>Singbox не поддерживает xhttp  и такой поддержки вроде как не будет, это во первых. А во вторых мультиплексирование будет работать только когда и клиент и сервер xray, насколько помню</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="0ka" data-post="70" data-topic="13855" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/letter_avatar_proxy/v4/letter/0/d78d45/48.png" class="avatar"> 0ka:</div>
<blockquote>
<p>В проге system informer вкладка network, там видно количество соединений. Singbox mux protocol не относится к xhttp, это встроенный mux в синге (работает с любым протоколом)</p>
</blockquote>
</aside>
<p>Спасибо за ответы.</p>
<p>Кажется мультиплексирование у меня работает (xhttp_reality) → я вижу одно подключение к VPS на 443 со своего компа (да, sing-box не включается c xhttp)</p>
<p>Проверил еще в режиме tcp_xtls-rprx-vision+reality → я вижу несколько подключений к VPS на 443 порту… (с xray и sing-box)</p>
<p>Клиент v2rayN. Получается мультиплексирование хорошо работает только в первом случае с xhttp ?</p>
<p>Через какое то время появилось второе подключение (в режиме xhttp), так и висят оба активными течении часа.</p></td><td>2025-01-07T11:19:51.899Z</td></tr><tr><td>wsvall</td><td><aside class="quote no-group quote-modified" data-username="hzdmnl" data-post="74" data-topic="13855" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/hzdmnl/48/14764_2.png" class="avatar"> hzdmnl:</div>
<blockquote>
<pre><code class="lang-auto">Вот рабочий конфиг xray клиента:

          "host": "несуществущюий_сайт.com",
          "path": "/здесь-несуществующий_путь_на_этом_сайте",
          "method": "GET"
</code></pre>
</blockquote>
</aside>
<p>Привет. У вас информация дает указание левого host и path ?<br>
У меня host пусто, path /</p></td><td>2025-01-07T13:42:34.500Z</td></tr><tr><td>hzdmnl(Hzdmnl)</td><td><p>Привет. Извините, не понял ваш вопрос.<br>
У меня указанно, примерно, так:</p>
<pre><code class="lang-auto">          "host": "prevedmedvedppppppp.com",
          "path": "/abirvalgkkkkkkkkkk",
          "method": "GET"
</code></pre></td><td>2025-01-07T18:17:06.025Z</td></tr><tr><td>MEQYR(MEQYR)</td><td><p>Ребят, можете подсказать как настроить xhttp+tls cdn CF? Просто уже сколько бьюсь над этим всё никак не рабоает, но другой .ru домен преспокойно работает всё с теми же настройками.</p></td><td>2025-01-08T06:40:04.094Z</td></tr><tr><td>wsvall</td><td><p>Вопрос в том, зачем указываете что-то в host и path ?<br>
По умолчанию <code>"host": пусто</code> , <code>"path": /</code><br>
Вот вы указали абракдабру эту и что изменилось, в отличии от настроек по умолчанию?</p></td><td>2025-01-08T10:59:02.369Z</td></tr><tr><td>NowAndThen</td><td><aside class="quote no-group" data-username="MEQYR" data-post="78" data-topic="13855">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://ntc.party/user_avatar/ntc.party/meqyr/48/14786_2.png" class="avatar"> MEQYR:</div>
<blockquote>
<p>как настроить xhttp+tls cdn CF</p>
</blockquote>
</aside>
<p><a href="https://habr.com/ru/articles/856602/" rel="noopener nofollow ugc">ECH отключен</a>?</p></td><td>2025-01-08T17:03:05.076Z</td></tr><tr><td>0ka(0ka)</td><td><p>Он поддерживается только синг боксом и включать нужно вручную</p></td><td>2025-01-09T16:55:19.424Z</td></tr><tr><td>MEQYR(MEQYR)</td><td><p>Да, отключил через curl</p></td><td>2025-01-12T10:14:36.431Z</td></tr><tr><td>Wallper(Сергей )</td><td><p>На андроид кроме v2rayNG какие еще приложения поддерживают xhttp ?</p></td><td>2025-01-24T10:02:49.411Z</td></tr><tr><td>naykaminka(Sergey)</td><td><p>Здравствуйте, как у вас дела с XHTTP ?<br>
Быть может появилась новая информация или заметки</p></td><td>2025-03-14T18:23:30.111Z</td></tr><tr><td>bashk8b</td><td><p>Кто-то использует xhttp+cloudflare+nginx(grpc_pass)? При проксировании через cloudflare прокси работает нестабильно, через некоторое время начинает тормозить или сбрасывать соединение, в логах вижу ошибки “сonnection end”. Если подключаться напрямую к VPS, прокси работает четко, ничего не тормозит. Как будто cloudflare по какой-то причине обрывает подключения grpc.</p></td><td>2025-03-18T12:33:54.897Z</td></tr><tr><td>0ka(0ka)</td><td><p>Cloudflare закрывает grpc соединения которые загрузили &gt;100мб, есть ли там ограничение на скачивание не знаю. А вообще на cloudflare есть вебсокет.</p></td><td>2025-03-18T15:27:45.745Z</td></tr><tr><td>Uporoty(Uporoty)</td><td><p>какая версия XRay? в самом новом релизе пару недель назад они там что-то поправили в протоколе как раз связанное с тем что CF рвал подключения после определенного времени.</p></td><td>2025-03-18T18:54:03.664Z</td></tr><tr><td>bashk8b</td><td><p>Версия xray последняя 25.3.6 на сервере и на клиенте. Но проблема все равно остается.</p></td><td>2025-03-19T06:40:59.147Z</td></tr><tr><td>armdyn</td><td><p>Я настраивал по <a href="https://github-com.translate.goog/XTLS/Xray-core/discussions/4118?_x_tr_sl=auto&amp;_x_tr_tl=en&amp;_x_tr_hl=en&amp;_x_tr_pto=wapp" rel="noopener nofollow ugc">китайским гайдам</a>, там 5 в 1.</p>
<p>С декабря и по начало марта работало всё очень хорошо, но потом действительно начались проблемы. Версии Xray на клиентах и на сервере обновлял по мере их выхода. Я использую варианты 3,4,5 и сейчас стабильно работает только 5, то есть когда аплинк идёт напрямую, а даунлинк через CF. В вариантах 3 и 4 там аплинк идёт тоже на CF и видимо в этом и проблема. На сервере в логах ошибок не пишет, соединения просто не доходят до сервера, в логах тишина. Если несколько раз пытаться обновить то примерно каждое пятое соединение срабатывает, логи на сервере оживают.<br>
Не знаю почему так стало, возможно это из-за новых ограничений исходящего трафика на CF, с даунлинком через CF проблемы не возникают.</p></td><td>2025-03-21T08:46:32.689Z</td></tr>
    </table>
      </body>
    </html>